{"file":"useAuth-C5hZCYX9.js","mappings":";;;;;;;AAGA,MAAM,oBAAoB;AACnB,SAAS,YAAY,MAAM;AAChC,QAAM,UAAU,OAAO,KAAK,KAAK,SAAS,CAAC,MAAM,WAAW,KAAK,IAAG,IAAK;AACzE,MAAI,OAAO,KAAK,CAAC,MAAM,UAAU;AAC/B,SAAK,QAAQ,OAAO;AAAA,EACtB;AACA,QAAM,CAAC,MAAM,IAAI,IAAI;AACrB,MAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;AACrC,UAAM,IAAI,UAAU,6CAA6C,IAAI;AAAA,EACvE;AACA,MAAI,SAAS,UAAU,OAAO,SAAS,YAAY;AACjD,UAAM,IAAI,MAAM,gDAAgD,IAAI;AAAA,EACtE;AACA,QAAM,MAAM,oBAAoB;AAChC,QAAM,UAAU,WAAU;AAC1B,QAAM,QAAQ,MAAM,QAAQ,QAAQ,OAAO,GAAG;AAC9C,MAAI,MAAM,UAAU,UAAU,MAAM;AAClC,UAAM,eAAe,KAAI;AACzB,QAAI,MAAM,YAAY,GAAG;AACvB,cAAQ,QAAQ,MAAM,GAAG,IAAI;AAC7B,aAAO;AAAA,IACT;AACA,UAAM,QAAQ;AAAA,EAChB;AACA,SAAO;AACT;ACvBO,SAAS,gBAAgB,SAAS;AAIvC,cAAY,WAAA;AACZ,SAAO,QAAQ,YAAY;AAC7B;ACFA,MAAM,iBAAiB;AAAA,EACrB,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ,CAAC,QAAQ,MAAM,mBAAmB,GAAG,CAAC;AAAA,EAC9C,QAAQ,CAAC,QAAQ,mBAAmB,OAAO,QAAQ,WAAW,MAAM,KAAK,UAAU,GAAG,CAAC;AACzF;AAEO,SAAS,UAAU,MAAM,OAAO;AACrC,QAAM,OAAO,EAAE,GAAG,gBAAgB,GAAG,MAAA;AACrC,OAAK,WAAW,CAAC,QAAQ,QAAQ;AACjC,QAAM,UAAU,eAAe,IAAI,KAAK,CAAA;AACxC,MAAI;AACJ,MAAI,KAAK,WAAW,QAAQ;AAC1B,YAAQ,KAAK,SAAS;AAAA,EACxB,WAAW,KAAK,SAAS;AACvB,YAAQ,KAAK,QAAQ,QAAA,IAAY,KAAK,IAAA;AAAA,EACxC;AACA,QAAM,aAAa,UAAU,UAAU,SAAS;AAEhD,QAAM,cAAc,MAAM,aAAa,SAAS,QAAQ,IAAI,KAAK,KAAK,WAAW;AACjF,QAAM,SAA8H,IAAI,WAAW;AAyEpH;AAC7B,UAAM,UAAU,WAAA;AAChB,UAAM,wBAAwB,MAAM;AAClC,UAAI,KAAK,YAAY,QAAQ,OAAO,OAAO,QAAQ,IAAI,CAAC,GAAG;AACzD;AAAA,MACF;AACA,cAAQ,aAAa,CAAA;AACrB,UAAI,QAAQ,QAAQ,UAAU;AAC5B,YAAI,QAAQ,OAAO,OAAO,QAAQ,SAAS,IAAI,CAAC,GAAG;AACjD;AAAA,QACF;AAAA,MAIF;AACA,cAAQ,SAAS,IAAI,IAAI,OAAO;AAChC,wBAAkB,gBAAgB,OAAO,GAAG,MAAM,OAAO,OAAO,IAAI;AAAA,IACtE;AACA,UAAM,SAAS,QAAQ,MAAM,SAAS,gBAAgB,qBAAqB;AAC3E,YAAQ,MAAM,SAAS,aAAa,MAAM;AACxC,aAAA;AACA,aAAO,sBAAA;AAAA,IACT,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAOA,SAAS,eAAe,OAAO,IAAI;AACT;AACtB,WAAO,MAAM,iBAAiB,gBAAA,GAAmB,QAAQ,KAAK,IAAI,IAAI;AAAA,EACxE;AAGF;AAYA,SAAS,kBAAkB,OAAO,MAAM,OAAO,OAAO,CAAA,GAAI;AACxD,MAAI,OAAO;AACT,QAAI,UAAU,QAAQ,UAAU,QAAQ;AACtC,aAAO,UAAU,OAAO,MAAM,OAAO,IAAI;AAAA,IAC3C;AACA,QAAI,UAAU,OAAO,IAAI,MAAM,QAAQ;AACrC,aAAO,aAAa,OAAO,MAAM,IAAI;AAAA,IACvC;AAAA,EACF;AACF;AC7JO,MAAM,UAAU,MAAM;AAE3B,QAAM,OAAO,SAAsB,aAAa,MAAM,IAAI;AAC1D,QAAM,kBAAkB,SAAS,MAAM,CAAC,CAAC,KAAK,KAAK;AACnD,QAAM,YAAY,IAAI,KAAK;AAC3B,QAAM,QAAQ,IAAmB,IAAI;AAGrC,QAAM,iBAAiB,YAAY;AACjC,QAAI;AACF,YAAM,QAAQ,UAAU,YAAY;AACpC,UAAI,MAAM,OAAO;AAEf,cAAM,WAAW,MAAM,OAAO,oBAAoB;AAAA,UAChD,QAAQ;AAAA,QAAA,CACT,EAAE,MAAM,MAAM,IAAI;AAEnB,YAAI,UAAU,WAAW,SAAS,MAAM;AACtC,eAAK,QAAQ,SAAS;AAAA,QACxB,OAAO;AAEL,gBAAM,QAAQ;AAAA,QAChB;AAAA,MACF;AAAA,IACF,SAAS,KAAK;AACZ,cAAQ,MAAM,cAAc,GAAG;AAC/B,YAAM,QAAQ,UAAU,YAAY;AACpC,YAAM,QAAQ;AAAA,IAChB;AAAA,EACF;AAGA,QAAM,QAAQ,OAAO,gBAAkC;AACrD,QAAI;AACF,gBAAU,QAAQ;AAClB,YAAM,QAAQ;AAEd,YAAM,WAAW,MAAM,OAAO,mBAAmB;AAAA,QAC/C,QAAQ;AAAA,QACR,MAAM;AAAA,MAAA,CACP;AAED,UAAI,SAAS,WAAW,SAAS,MAAM;AACrC,aAAK,QAAQ,SAAS,KAAK;AAE3B,eAAO,SAAS;AAAA,MAClB,OAAO;AACL,cAAM,IAAI,MAAM,MAAM;AAAA,MACxB;AAAA,IACF,SAAS,KAAU;AACjB,YAAM,QAAQ,IAAI,MAAM,iBAAiB,IAAI,WAAW;AACxD,YAAM;AAAA,IACR,UAAA;AACE,gBAAU,QAAQ;AAAA,IACpB;AAAA,EACF;AAGA,QAAM,WAAW,OAAO,SAAuB;AAC7C,QAAI;AACF,gBAAU,QAAQ;AAClB,YAAM,QAAQ;AAEd,YAAM,WAAW,MAAM,OAAO,sBAAsB;AAAA,QAClD,QAAQ;AAAA,QACR,MAAM;AAAA,MAAA,CACP;AAED,UAAI,SAAS,WAAW,SAAS,MAAM;AACrC,aAAK,QAAQ,SAAS,KAAK;AAE3B,eAAO,SAAS;AAAA,MAClB,OAAO;AACL,cAAM,IAAI,MAAM,MAAM;AAAA,MACxB;AAAA,IACF,SAAS,KAAU;AACjB,YAAM,QAAQ,IAAI,MAAM,iBAAiB,IAAI,WAAW;AACxD,YAAM;AAAA,IACR,UAAA;AACE,gBAAU,QAAQ;AAAA,IACpB;AAAA,EACF;AAGA,QAAM,SAAS,YAAY;AACzB,QAAI;AACF,YAAM,OAAO,oBAAoB;AAAA,QAC/B,QAAQ;AAAA,MAAA,CACT;AAAA,IACH,SAAS,KAAK;AACZ,cAAQ,MAAM,aAAa,GAAG;AAAA,IAChC,UAAA;AAEE,WAAK,QAAQ;AACb,YAAM,QAAQ,UAAU,YAAY;AACpC,YAAM,QAAQ;AACd,YAAM,WAAW,QAAQ;AAAA,IAC3B;AAAA,EACF;AAGA,QAAM,gBAAgB,OAAO,SAAwB;AACnD,QAAI;AACF,gBAAU,QAAQ;AAClB,YAAM,QAAQ;AAEd,YAAM,WAAW,MAAM,OAAO,qBAAqB;AAAA,QACjD,QAAQ;AAAA,QACR,MAAM;AAAA,MAAA,CACP;AAED,UAAI,SAAS,WAAW,SAAS,MAAM;AACrC,aAAK,QAAQ,SAAS;AACtB,eAAO,SAAS;AAAA,MAClB,OAAO;AACL,cAAM,IAAI,MAAM,UAAU;AAAA,MAC5B;AAAA,IACF,SAAS,KAAU;AACjB,YAAM,QAAQ,IAAI,MAAM,iBAAiB,IAAI,WAAW;AACxD,YAAM;AAAA,IACR,UAAA;AACE,gBAAU,QAAQ;AAAA,IACpB;AAAA,EACF;AAGA,QAAM,oBAAoB,OAAO,gBAAqB;AACpD,QAAI;AACF,gBAAU,QAAQ;AAClB,YAAM,QAAQ;AAEd,YAAM,WAAW,MAAM,OAAO,yBAAyB;AAAA,QACrD,QAAQ;AAAA,QACR,MAAM,EAAE,YAAA;AAAA,MAAY,CACrB;AAED,UAAI,SAAS,WAAW,SAAS,MAAM;AACrC,YAAI,KAAK,OAAO;AACd,eAAK,MAAM,cAAc,EAAE,GAAG,KAAK,MAAM,aAAa,GAAG,YAAA;AAAA,QAC3D;AACA,eAAO,SAAS;AAAA,MAClB,OAAO;AACL,cAAM,IAAI,MAAM,UAAU;AAAA,MAC5B;AAAA,IACF,SAAS,KAAU;AACjB,YAAM,QAAQ,IAAI,MAAM,iBAAiB,IAAI,WAAW;AACxD,YAAM;AAAA,IACR,UAAA;AACE,gBAAU,QAAQ;AAAA,IACpB;AAAA,EACF;AAGA,QAAM,cAAc,YAAY;AAC9B,QAAI,CAAC,gBAAgB,MAAO;AAE5B,QAAI;AACF,YAAM,WAAW,MAAM,OAAO,qBAAqB;AAAA,QACjD,QAAQ;AAAA,MAAA,CACT;AAED,UAAI,SAAS,WAAW,SAAS,MAAM;AACrC,aAAK,QAAQ,SAAS;AAAA,MACxB;AAAA,IACF,SAAS,KAAK;AACZ,cAAQ,MAAM,aAAa,GAAG;AAAA,IAChC;AAAA,EACF;AAGA,QAAM,gBAAgB,CAAC,eAAuB;AAC5C,QAAI,CAAC,KAAK,MAAO,QAAO;AAExB,WAAO;AAAA,EACT;AAEA,SAAO;AAAA;AAAA,IAEL,MAAM,SAAS,IAAI;AAAA,IACnB;AAAA,IACA,WAAW,SAAS,SAAS;AAAA,IAC7B,OAAO,SAAS,KAAK;AAAA;AAAA,IAGrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ;","names":[],"sources":["../../../../node_modules/nuxt/dist/app/composables/state.js","../../../../node_modules/nuxt/dist/app/composables/ssr.js","../../../../node_modules/nuxt/dist/app/composables/cookie.js","../../../../composables/useAuth.ts"],"sourcesContent":["import { isRef, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nconst useStateKeyPrefix = \"$s\";\nexport function useState(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [_key, init] = args;\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useState] key must be a string: \" + _key);\n  }\n  if (init !== void 0 && typeof init !== \"function\") {\n    throw new Error(\"[nuxt] [useState] init must be a function: \" + init);\n  }\n  const key = useStateKeyPrefix + _key;\n  const nuxtApp = useNuxtApp();\n  const state = toRef(nuxtApp.payload.state, key);\n  if (state.value === void 0 && init) {\n    const initialValue = init();\n    if (isRef(initialValue)) {\n      nuxtApp.payload.state[key] = initialValue;\n      return initialValue;\n    }\n    state.value = initialValue;\n  }\n  return state;\n}\nexport function clearNuxtState(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.state).map((key) => key.substring(useStateKeyPrefix.length));\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const _key of _keys) {\n    const key = useStateKeyPrefix + _key;\n    if (key in nuxtApp.payload.state) {\n      nuxtApp.payload.state[key] = void 0;\n    }\n  }\n}\n","import { setResponseStatus as _setResponseStatus, appendHeader, getRequestHeader, getRequestHeaders, getResponseHeader, removeResponseHeader, setResponseHeader } from \"h3\";\nimport { computed, getCurrentInstance, ref } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { useHead } from \"./head.js\";\nexport function useRequestEvent(nuxtApp) {\n  if (import.meta.client) {\n    return;\n  }\n  nuxtApp ||= useNuxtApp();\n  return nuxtApp.ssrContext?.event;\n}\nexport function useRequestHeaders(include) {\n  if (import.meta.client) {\n    return {};\n  }\n  const event = useRequestEvent();\n  const _headers = event ? getRequestHeaders(event) : {};\n  if (!include || !event) {\n    return _headers;\n  }\n  const headers = /* @__PURE__ */ Object.create(null);\n  for (const _key of include) {\n    const key = _key.toLowerCase();\n    const header = _headers[key];\n    if (header) {\n      headers[key] = header;\n    }\n  }\n  return headers;\n}\nexport function useRequestHeader(header) {\n  if (import.meta.client) {\n    return void 0;\n  }\n  const event = useRequestEvent();\n  return event ? getRequestHeader(event, header) : void 0;\n}\nexport function useRequestFetch() {\n  if (import.meta.client) {\n    return globalThis.$fetch;\n  }\n  return useRequestEvent()?.$fetch || globalThis.$fetch;\n}\nexport function setResponseStatus(arg1, arg2, arg3) {\n  if (import.meta.client) {\n    return;\n  }\n  if (arg1 && typeof arg1 !== \"number\") {\n    return _setResponseStatus(arg1, arg2, arg3);\n  }\n  const event = useRequestEvent();\n  if (event) {\n    return _setResponseStatus(event, arg1, arg2);\n  }\n}\nexport function useResponseHeader(header) {\n  if (import.meta.client) {\n    if (import.meta.dev) {\n      return computed({\n        get: () => void 0,\n        set: () => console.warn(\"[nuxt] Setting response headers is not supported in the browser.\")\n      });\n    }\n    return ref();\n  }\n  const event = useRequestEvent();\n  return computed({\n    get() {\n      return getResponseHeader(event, header);\n    },\n    set(newValue) {\n      if (!newValue) {\n        return removeResponseHeader(event, header);\n      }\n      return setResponseHeader(event, header, newValue);\n    }\n  });\n}\nexport function prerenderRoutes(path) {\n  if (!import.meta.server || !import.meta.prerender) {\n    return;\n  }\n  const paths = toArray(path);\n  appendHeader(useRequestEvent(), \"x-nitro-prerender\", paths.map((p) => encodeURIComponent(p)).join(\", \"));\n}\nconst PREHYDRATE_ATTR_KEY = \"data-prehydrate-id\";\nexport function onPrehydrate(callback, key) {\n  if (import.meta.client) {\n    return;\n  }\n  if (typeof callback !== \"string\") {\n    throw new TypeError(\"[nuxt] To transform a callback into a string, `onPrehydrate` must be processed by the Nuxt build pipeline. If it is called in a third-party library, make sure to add the library to `build.transpile`.\");\n  }\n  const vm = getCurrentInstance();\n  if (vm && key) {\n    vm.attrs[PREHYDRATE_ATTR_KEY] ||= \"\";\n    key = \":\" + key + \":\";\n    if (!vm.attrs[PREHYDRATE_ATTR_KEY].includes(key)) {\n      vm.attrs[PREHYDRATE_ATTR_KEY] += key;\n    }\n  }\n  const code = vm && key ? `document.querySelectorAll('[${PREHYDRATE_ATTR_KEY}*=${JSON.stringify(key)}]').forEach` + callback : callback + \"()\";\n  useHead({\n    script: [{\n      key: vm && key ? key : void 0,\n      tagPosition: \"bodyClose\",\n      tagPriority: \"critical\",\n      innerHTML: code\n    }]\n  });\n  return vm && key ? vm.attrs[PREHYDRATE_ATTR_KEY] : void 0;\n}\n","import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { deleteCookie, getCookie, getRequestHeader, setCookie } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRequestEvent } from \"./ssr.js\";\nimport { cookieStore } from \"#build/nuxt.config.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nconst store = import.meta.client && cookieStore ? globalThis.cookieStore : void 0;\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  opts.filter ??= (key) => key === name;\n  const cookies = readRawCookies(opts) || {};\n  let delay;\n  if (opts.maxAge !== void 0) {\n    delay = opts.maxAge * 1e3;\n  } else if (opts.expires) {\n    delay = opts.expires.getTime() - Date.now();\n  }\n  const hasExpired = delay !== void 0 && delay <= 0;\n  const shouldSetInitialClientCookie = import.meta.client && (hasExpired || cookies[name] === void 0 || cookies[name] === null);\n  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());\n  const cookie = import.meta.client && delay && !hasExpired ? cookieRef(cookieValue, delay, opts.watch && opts.watch !== \"shallow\") : ref(cookieValue);\n  if (import.meta.dev && hasExpired) {\n    console.warn(`[nuxt] not setting cookie \\`${name}\\` as it has already expired.`);\n  }\n  if (import.meta.client) {\n    let channel = null;\n    try {\n      if (!store && typeof BroadcastChannel !== \"undefined\") {\n        channel = new BroadcastChannel(`nuxt:cookies:${name}`);\n      }\n    } catch {\n    }\n    const callback = (force = false) => {\n      if (!force) {\n        if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n          return;\n        }\n      }\n      writeClientCookie(name, cookie.value, opts);\n      cookies[name] = klona(cookie.value);\n      channel?.postMessage({ value: opts.encode(cookie.value) });\n    };\n    const handleChange = (data) => {\n      const value = data.refresh ? readRawCookies(opts)?.[name] : opts.decode(data.value);\n      watchPaused = true;\n      cookie.value = value;\n      cookies[name] = klona(value);\n      nextTick(() => {\n        watchPaused = false;\n      });\n    };\n    let watchPaused = false;\n    const hasScope = !!getCurrentScope();\n    if (hasScope) {\n      onScopeDispose(() => {\n        watchPaused = true;\n        callback();\n        channel?.close();\n      });\n    }\n    if (store) {\n      const changeHandler = (event) => {\n        const changedCookie = event.changed.find((c) => c.name === name);\n        const removedCookie = event.deleted.find((c) => c.name === name);\n        if (changedCookie) {\n          handleChange({ value: changedCookie.value });\n        }\n        if (removedCookie) {\n          handleChange({ value: null });\n        }\n      };\n      store.addEventListener(\"change\", changeHandler);\n      if (hasScope) {\n        onScopeDispose(() => store.removeEventListener(\"change\", changeHandler));\n      }\n    } else if (channel) {\n      channel.onmessage = ({ data }) => handleChange(data);\n    }\n    if (opts.watch) {\n      watch(\n        cookie,\n        () => {\n          if (watchPaused) {\n            return;\n          }\n          callback();\n        },\n        { deep: opts.watch !== \"shallow\" }\n      );\n    }\n    if (shouldSetInitialClientCookie) {\n      callback(shouldSetInitialClientCookie);\n    }\n  } else if (import.meta.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      nuxtApp._cookies ||= {};\n      if (name in nuxtApp._cookies) {\n        if (isEqual(cookie.value, nuxtApp._cookies[name])) {\n          return;\n        }\n        if (import.meta.dev) {\n          console.warn(`[nuxt] cookie \\`${name}\\` was previously set to \\`${opts.encode(nuxtApp._cookies[name])}\\` and is being overridden to \\`${opts.encode(cookie.value)}\\`. This may cause unexpected issues.`);\n        }\n      }\n      nuxtApp._cookies[name] = cookie.value;\n      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:error\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nexport function refreshCookie(name) {\n  if (import.meta.server || store || typeof BroadcastChannel === \"undefined\") {\n    return;\n  }\n  new BroadcastChannel(`nuxt:cookies:${name}`)?.postMessage({ refresh: true });\n}\nfunction readRawCookies(opts = {}) {\n  if (import.meta.server) {\n    return parse(getRequestHeader(useRequestEvent(), \"cookie\") || \"\", opts);\n  } else if (import.meta.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (import.meta.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    if (value !== null && value !== void 0) {\n      return setCookie(event, name, value, opts);\n    }\n    if (getCookie(event, name) !== void 0) {\n      return deleteCookie(event, name, opts);\n    }\n  }\n}\nconst MAX_TIMEOUT_DELAY = 2147483647;\nfunction cookieRef(value, delay, shouldWatch) {\n  let timeout;\n  let unsubscribe;\n  let elapsed = 0;\n  const internalRef = shouldWatch ? ref(value) : { value };\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      unsubscribe?.();\n      clearTimeout(timeout);\n    });\n  }\n  return customRef((track, trigger) => {\n    if (shouldWatch) {\n      unsubscribe = watch(internalRef, trigger);\n    }\n    function createExpirationTimeout() {\n      elapsed = 0;\n      clearTimeout(timeout);\n      const timeRemaining = delay - elapsed;\n      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY;\n      timeout = setTimeout(() => {\n        elapsed += timeoutLength;\n        if (elapsed < delay) {\n          return createExpirationTimeout();\n        }\n        internalRef.value = void 0;\n        trigger();\n      }, timeoutLength);\n    }\n    return {\n      get() {\n        track();\n        return internalRef.value;\n      },\n      set(newValue) {\n        createExpirationTimeout();\n        internalRef.value = newValue;\n        trigger();\n      }\n    };\n  });\n}\n","import { ref, computed, readonly } from 'vue'\nimport type { User, LoginCredentials, RegisterData } from '~/types/auth'\n\n// 认证状态\nexport const useAuth = () => {\n  // 用户状态\n  const user = useState<User | null>('auth-user', () => null)\n  const isAuthenticated = computed(() => !!user.value)\n  const isLoading = ref(false)\n  const error = ref<string | null>(null)\n\n  // 从Cookie恢复认证状态\n  const initializeAuth = async () => {\n    try {\n      const token = useCookie('auth-token')\n      if (token.value) {\n        // 验证token并获取用户信息\n        const response = await $fetch('/api/auth/verify', {\n          method: 'GET'\n        }).catch(() => null)\n\n        if (response?.success && response.data) {\n          user.value = response.data\n        } else {\n          // Token无效，清除Cookie\n          token.value = null\n        }\n      }\n    } catch (err) {\n      console.error('初始化认证状态失败:', err)\n      const token = useCookie('auth-token')\n      token.value = null\n    }\n  }\n\n  // 用户登录\n  const login = async (credentials: LoginCredentials) => {\n    try {\n      isLoading.value = true\n      error.value = null\n\n      const response = await $fetch('/api/auth/login', {\n        method: 'POST',\n        body: credentials\n      })\n\n      if (response.success && response.data) {\n        user.value = response.data.user\n        // Cookie会在服务端自动设置\n        return response.data\n      } else {\n        throw new Error('登录失败')\n      }\n    } catch (err: any) {\n      error.value = err.data?.statusMessage || err.message || '登录失败'\n      throw err\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  // 用户注册\n  const register = async (data: RegisterData) => {\n    try {\n      isLoading.value = true\n      error.value = null\n\n      const response = await $fetch('/api/auth/register', {\n        method: 'POST',\n        body: data\n      })\n\n      if (response.success && response.data) {\n        user.value = response.data.user\n        // Cookie会在服务端自动设置\n        return response.data\n      } else {\n        throw new Error('注册失败')\n      }\n    } catch (err: any) {\n      error.value = err.data?.statusMessage || err.message || '注册失败'\n      throw err\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  // 用户退出\n  const logout = async () => {\n    try {\n      await $fetch('/api/auth/logout', {\n        method: 'POST'\n      })\n    } catch (err) {\n      console.error('退出登录请求失败:', err)\n    } finally {\n      // 无论服务端请求是否成功，都清除本地状态\n      user.value = null\n      const token = useCookie('auth-token')\n      token.value = null\n      await navigateTo('/login')\n    }\n  }\n\n  // 更新用户信息\n  const updateProfile = async (data: Partial<User>) => {\n    try {\n      isLoading.value = true\n      error.value = null\n\n      const response = await $fetch('/api/user/profile', {\n        method: 'PUT',\n        body: data\n      })\n\n      if (response.success && response.data) {\n        user.value = response.data\n        return response.data\n      } else {\n        throw new Error('更新用户信息失败')\n      }\n    } catch (err: any) {\n      error.value = err.data?.statusMessage || err.message || '更新用户信息失败'\n      throw err\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  // 更新用户偏好设置\n  const updatePreferences = async (preferences: any) => {\n    try {\n      isLoading.value = true\n      error.value = null\n\n      const response = await $fetch('/api/user/preferences', {\n        method: 'PUT',\n        body: { preferences }\n      })\n\n      if (response.success && response.data) {\n        if (user.value) {\n          user.value.preferences = { ...user.value.preferences, ...preferences }\n        }\n        return response.data\n      } else {\n        throw new Error('更新偏好设置失败')\n      }\n    } catch (err: any) {\n      error.value = err.data?.statusMessage || err.message || '更新偏好设置失败'\n      throw err\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  // 刷新用户信息\n  const refreshUser = async () => {\n    if (!isAuthenticated.value) return\n\n    try {\n      const response = await $fetch('/api/user/profile', {\n        method: 'GET'\n      })\n\n      if (response.success && response.data) {\n        user.value = response.data\n      }\n    } catch (err) {\n      console.error('刷新用户信息失败:', err)\n    }\n  }\n\n  // 检查用户权限\n  const hasPermission = (permission: string) => {\n    if (!user.value) return false\n    // 这里可以根据用户角色权限系统实现\n    return true\n  }\n\n  return {\n    // 状态\n    user: readonly(user),\n    isAuthenticated,\n    isLoading: readonly(isLoading),\n    error: readonly(error),\n\n    // 方法\n    initializeAuth,\n    login,\n    register,\n    logout,\n    updateProfile,\n    updatePreferences,\n    refreshUser,\n    hasPermission\n  }\n}"],"version":3}