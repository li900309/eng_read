
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VocabularyCategory
 * 
 */
export type VocabularyCategory = $Result.DefaultSelection<Prisma.$VocabularyCategoryPayload>
/**
 * Model Vocabulary
 * 
 */
export type Vocabulary = $Result.DefaultSelection<Prisma.$VocabularyPayload>
/**
 * Model UserVocabulary
 * 
 */
export type UserVocabulary = $Result.DefaultSelection<Prisma.$UserVocabularyPayload>
/**
 * Model LearningSession
 * 
 */
export type LearningSession = $Result.DefaultSelection<Prisma.$LearningSessionPayload>
/**
 * Model LearningSessionRecord
 * 
 */
export type LearningSessionRecord = $Result.DefaultSelection<Prisma.$LearningSessionRecordPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model ReadingArticle
 * 
 */
export type ReadingArticle = $Result.DefaultSelection<Prisma.$ReadingArticlePayload>
/**
 * Model UserReadingRecord
 * 
 */
export type UserReadingRecord = $Result.DefaultSelection<Prisma.$UserReadingRecordPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.vocabularyCategory`: Exposes CRUD operations for the **VocabularyCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VocabularyCategories
    * const vocabularyCategories = await prisma.vocabularyCategory.findMany()
    * ```
    */
  get vocabularyCategory(): Prisma.VocabularyCategoryDelegate<ExtArgs>;

  /**
   * `prisma.vocabulary`: Exposes CRUD operations for the **Vocabulary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vocabularies
    * const vocabularies = await prisma.vocabulary.findMany()
    * ```
    */
  get vocabulary(): Prisma.VocabularyDelegate<ExtArgs>;

  /**
   * `prisma.userVocabulary`: Exposes CRUD operations for the **UserVocabulary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserVocabularies
    * const userVocabularies = await prisma.userVocabulary.findMany()
    * ```
    */
  get userVocabulary(): Prisma.UserVocabularyDelegate<ExtArgs>;

  /**
   * `prisma.learningSession`: Exposes CRUD operations for the **LearningSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningSessions
    * const learningSessions = await prisma.learningSession.findMany()
    * ```
    */
  get learningSession(): Prisma.LearningSessionDelegate<ExtArgs>;

  /**
   * `prisma.learningSessionRecord`: Exposes CRUD operations for the **LearningSessionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningSessionRecords
    * const learningSessionRecords = await prisma.learningSessionRecord.findMany()
    * ```
    */
  get learningSessionRecord(): Prisma.LearningSessionRecordDelegate<ExtArgs>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs>;

  /**
   * `prisma.readingArticle`: Exposes CRUD operations for the **ReadingArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReadingArticles
    * const readingArticles = await prisma.readingArticle.findMany()
    * ```
    */
  get readingArticle(): Prisma.ReadingArticleDelegate<ExtArgs>;

  /**
   * `prisma.userReadingRecord`: Exposes CRUD operations for the **UserReadingRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserReadingRecords
    * const userReadingRecords = await prisma.userReadingRecord.findMany()
    * ```
    */
  get userReadingRecord(): Prisma.UserReadingRecordDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    VocabularyCategory: 'VocabularyCategory',
    Vocabulary: 'Vocabulary',
    UserVocabulary: 'UserVocabulary',
    LearningSession: 'LearningSession',
    LearningSessionRecord: 'LearningSessionRecord',
    UserAchievement: 'UserAchievement',
    ReadingArticle: 'ReadingArticle',
    UserReadingRecord: 'UserReadingRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "vocabularyCategory" | "vocabulary" | "userVocabulary" | "learningSession" | "learningSessionRecord" | "userAchievement" | "readingArticle" | "userReadingRecord"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VocabularyCategory: {
        payload: Prisma.$VocabularyCategoryPayload<ExtArgs>
        fields: Prisma.VocabularyCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VocabularyCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VocabularyCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload>
          }
          findFirst: {
            args: Prisma.VocabularyCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VocabularyCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload>
          }
          findMany: {
            args: Prisma.VocabularyCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload>[]
          }
          create: {
            args: Prisma.VocabularyCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload>
          }
          createMany: {
            args: Prisma.VocabularyCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VocabularyCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload>[]
          }
          delete: {
            args: Prisma.VocabularyCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload>
          }
          update: {
            args: Prisma.VocabularyCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload>
          }
          deleteMany: {
            args: Prisma.VocabularyCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VocabularyCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VocabularyCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyCategoryPayload>
          }
          aggregate: {
            args: Prisma.VocabularyCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVocabularyCategory>
          }
          groupBy: {
            args: Prisma.VocabularyCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VocabularyCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VocabularyCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<VocabularyCategoryCountAggregateOutputType> | number
          }
        }
      }
      Vocabulary: {
        payload: Prisma.$VocabularyPayload<ExtArgs>
        fields: Prisma.VocabularyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VocabularyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VocabularyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          findFirst: {
            args: Prisma.VocabularyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VocabularyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          findMany: {
            args: Prisma.VocabularyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>[]
          }
          create: {
            args: Prisma.VocabularyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          createMany: {
            args: Prisma.VocabularyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VocabularyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>[]
          }
          delete: {
            args: Prisma.VocabularyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          update: {
            args: Prisma.VocabularyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          deleteMany: {
            args: Prisma.VocabularyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VocabularyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VocabularyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          aggregate: {
            args: Prisma.VocabularyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVocabulary>
          }
          groupBy: {
            args: Prisma.VocabularyGroupByArgs<ExtArgs>
            result: $Utils.Optional<VocabularyGroupByOutputType>[]
          }
          count: {
            args: Prisma.VocabularyCountArgs<ExtArgs>
            result: $Utils.Optional<VocabularyCountAggregateOutputType> | number
          }
        }
      }
      UserVocabulary: {
        payload: Prisma.$UserVocabularyPayload<ExtArgs>
        fields: Prisma.UserVocabularyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserVocabularyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserVocabularyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload>
          }
          findFirst: {
            args: Prisma.UserVocabularyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserVocabularyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload>
          }
          findMany: {
            args: Prisma.UserVocabularyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload>[]
          }
          create: {
            args: Prisma.UserVocabularyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload>
          }
          createMany: {
            args: Prisma.UserVocabularyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserVocabularyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload>[]
          }
          delete: {
            args: Prisma.UserVocabularyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload>
          }
          update: {
            args: Prisma.UserVocabularyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload>
          }
          deleteMany: {
            args: Prisma.UserVocabularyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserVocabularyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserVocabularyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVocabularyPayload>
          }
          aggregate: {
            args: Prisma.UserVocabularyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserVocabulary>
          }
          groupBy: {
            args: Prisma.UserVocabularyGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserVocabularyGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserVocabularyCountArgs<ExtArgs>
            result: $Utils.Optional<UserVocabularyCountAggregateOutputType> | number
          }
        }
      }
      LearningSession: {
        payload: Prisma.$LearningSessionPayload<ExtArgs>
        fields: Prisma.LearningSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          findFirst: {
            args: Prisma.LearningSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          findMany: {
            args: Prisma.LearningSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>[]
          }
          create: {
            args: Prisma.LearningSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          createMany: {
            args: Prisma.LearningSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>[]
          }
          delete: {
            args: Prisma.LearningSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          update: {
            args: Prisma.LearningSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          deleteMany: {
            args: Prisma.LearningSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearningSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          aggregate: {
            args: Prisma.LearningSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningSession>
          }
          groupBy: {
            args: Prisma.LearningSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningSessionCountArgs<ExtArgs>
            result: $Utils.Optional<LearningSessionCountAggregateOutputType> | number
          }
        }
      }
      LearningSessionRecord: {
        payload: Prisma.$LearningSessionRecordPayload<ExtArgs>
        fields: Prisma.LearningSessionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningSessionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningSessionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload>
          }
          findFirst: {
            args: Prisma.LearningSessionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningSessionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload>
          }
          findMany: {
            args: Prisma.LearningSessionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload>[]
          }
          create: {
            args: Prisma.LearningSessionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload>
          }
          createMany: {
            args: Prisma.LearningSessionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningSessionRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload>[]
          }
          delete: {
            args: Prisma.LearningSessionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload>
          }
          update: {
            args: Prisma.LearningSessionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload>
          }
          deleteMany: {
            args: Prisma.LearningSessionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningSessionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearningSessionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionRecordPayload>
          }
          aggregate: {
            args: Prisma.LearningSessionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningSessionRecord>
          }
          groupBy: {
            args: Prisma.LearningSessionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningSessionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningSessionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<LearningSessionRecordCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      ReadingArticle: {
        payload: Prisma.$ReadingArticlePayload<ExtArgs>
        fields: Prisma.ReadingArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReadingArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReadingArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload>
          }
          findFirst: {
            args: Prisma.ReadingArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReadingArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload>
          }
          findMany: {
            args: Prisma.ReadingArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload>[]
          }
          create: {
            args: Prisma.ReadingArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload>
          }
          createMany: {
            args: Prisma.ReadingArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReadingArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload>[]
          }
          delete: {
            args: Prisma.ReadingArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload>
          }
          update: {
            args: Prisma.ReadingArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload>
          }
          deleteMany: {
            args: Prisma.ReadingArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReadingArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReadingArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingArticlePayload>
          }
          aggregate: {
            args: Prisma.ReadingArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReadingArticle>
          }
          groupBy: {
            args: Prisma.ReadingArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReadingArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReadingArticleCountArgs<ExtArgs>
            result: $Utils.Optional<ReadingArticleCountAggregateOutputType> | number
          }
        }
      }
      UserReadingRecord: {
        payload: Prisma.$UserReadingRecordPayload<ExtArgs>
        fields: Prisma.UserReadingRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserReadingRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserReadingRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload>
          }
          findFirst: {
            args: Prisma.UserReadingRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserReadingRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload>
          }
          findMany: {
            args: Prisma.UserReadingRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload>[]
          }
          create: {
            args: Prisma.UserReadingRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload>
          }
          createMany: {
            args: Prisma.UserReadingRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserReadingRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload>[]
          }
          delete: {
            args: Prisma.UserReadingRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload>
          }
          update: {
            args: Prisma.UserReadingRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload>
          }
          deleteMany: {
            args: Prisma.UserReadingRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserReadingRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserReadingRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReadingRecordPayload>
          }
          aggregate: {
            args: Prisma.UserReadingRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserReadingRecord>
          }
          groupBy: {
            args: Prisma.UserReadingRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserReadingRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserReadingRecordCountArgs<ExtArgs>
            result: $Utils.Optional<UserReadingRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    vocabularies: number
    learningSessions: number
    achievements: number
    userReadingRecords: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vocabularies?: boolean | UserCountOutputTypeCountVocabulariesArgs
    learningSessions?: boolean | UserCountOutputTypeCountLearningSessionsArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    userReadingRecords?: boolean | UserCountOutputTypeCountUserReadingRecordsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVocabulariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserVocabularyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLearningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserReadingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserReadingRecordWhereInput
  }


  /**
   * Count Type VocabularyCategoryCountOutputType
   */

  export type VocabularyCategoryCountOutputType = {
    vocabularies: number
  }

  export type VocabularyCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vocabularies?: boolean | VocabularyCategoryCountOutputTypeCountVocabulariesArgs
  }

  // Custom InputTypes
  /**
   * VocabularyCategoryCountOutputType without action
   */
  export type VocabularyCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategoryCountOutputType
     */
    select?: VocabularyCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VocabularyCategoryCountOutputType without action
   */
  export type VocabularyCategoryCountOutputTypeCountVocabulariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VocabularyWhereInput
  }


  /**
   * Count Type VocabularyCountOutputType
   */

  export type VocabularyCountOutputType = {
    userVocabularies: number
    sessionRecords: number
  }

  export type VocabularyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userVocabularies?: boolean | VocabularyCountOutputTypeCountUserVocabulariesArgs
    sessionRecords?: boolean | VocabularyCountOutputTypeCountSessionRecordsArgs
  }

  // Custom InputTypes
  /**
   * VocabularyCountOutputType without action
   */
  export type VocabularyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCountOutputType
     */
    select?: VocabularyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VocabularyCountOutputType without action
   */
  export type VocabularyCountOutputTypeCountUserVocabulariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserVocabularyWhereInput
  }

  /**
   * VocabularyCountOutputType without action
   */
  export type VocabularyCountOutputTypeCountSessionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionRecordWhereInput
  }


  /**
   * Count Type LearningSessionCountOutputType
   */

  export type LearningSessionCountOutputType = {
    sessionRecords: number
  }

  export type LearningSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionRecords?: boolean | LearningSessionCountOutputTypeCountSessionRecordsArgs
  }

  // Custom InputTypes
  /**
   * LearningSessionCountOutputType without action
   */
  export type LearningSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionCountOutputType
     */
    select?: LearningSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearningSessionCountOutputType without action
   */
  export type LearningSessionCountOutputTypeCountSessionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionRecordWhereInput
  }


  /**
   * Count Type ReadingArticleCountOutputType
   */

  export type ReadingArticleCountOutputType = {
    userReadingRecords: number
  }

  export type ReadingArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userReadingRecords?: boolean | ReadingArticleCountOutputTypeCountUserReadingRecordsArgs
  }

  // Custom InputTypes
  /**
   * ReadingArticleCountOutputType without action
   */
  export type ReadingArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticleCountOutputType
     */
    select?: ReadingArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReadingArticleCountOutputType without action
   */
  export type ReadingArticleCountOutputTypeCountUserReadingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserReadingRecordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    preferences: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    preferences: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    isActive: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    preferences: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    preferences?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    preferences?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    preferences?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    preferences: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    preferences?: boolean
    vocabularies?: boolean | User$vocabulariesArgs<ExtArgs>
    learningSessions?: boolean | User$learningSessionsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    userReadingRecords?: boolean | User$userReadingRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    preferences?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    preferences?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vocabularies?: boolean | User$vocabulariesArgs<ExtArgs>
    learningSessions?: boolean | User$learningSessionsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    userReadingRecords?: boolean | User$userReadingRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      vocabularies: Prisma.$UserVocabularyPayload<ExtArgs>[]
      learningSessions: Prisma.$LearningSessionPayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      userReadingRecords: Prisma.$UserReadingRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
      preferences: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vocabularies<T extends User$vocabulariesArgs<ExtArgs> = {}>(args?: Subset<T, User$vocabulariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "findMany"> | Null>
    learningSessions<T extends User$learningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$learningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    userReadingRecords<T extends User$userReadingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$userReadingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly preferences: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.vocabularies
   */
  export type User$vocabulariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    where?: UserVocabularyWhereInput
    orderBy?: UserVocabularyOrderByWithRelationInput | UserVocabularyOrderByWithRelationInput[]
    cursor?: UserVocabularyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserVocabularyScalarFieldEnum | UserVocabularyScalarFieldEnum[]
  }

  /**
   * User.learningSessions
   */
  export type User$learningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    where?: LearningSessionWhereInput
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    cursor?: LearningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.userReadingRecords
   */
  export type User$userReadingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    where?: UserReadingRecordWhereInput
    orderBy?: UserReadingRecordOrderByWithRelationInput | UserReadingRecordOrderByWithRelationInput[]
    cursor?: UserReadingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserReadingRecordScalarFieldEnum | UserReadingRecordScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model VocabularyCategory
   */

  export type AggregateVocabularyCategory = {
    _count: VocabularyCategoryCountAggregateOutputType | null
    _min: VocabularyCategoryMinAggregateOutputType | null
    _max: VocabularyCategoryMaxAggregateOutputType | null
  }

  export type VocabularyCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VocabularyCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VocabularyCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VocabularyCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VocabularyCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VocabularyCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VocabularyCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VocabularyCategory to aggregate.
     */
    where?: VocabularyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VocabularyCategories to fetch.
     */
    orderBy?: VocabularyCategoryOrderByWithRelationInput | VocabularyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VocabularyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VocabularyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VocabularyCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VocabularyCategories
    **/
    _count?: true | VocabularyCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VocabularyCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VocabularyCategoryMaxAggregateInputType
  }

  export type GetVocabularyCategoryAggregateType<T extends VocabularyCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateVocabularyCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVocabularyCategory[P]>
      : GetScalarType<T[P], AggregateVocabularyCategory[P]>
  }




  export type VocabularyCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VocabularyCategoryWhereInput
    orderBy?: VocabularyCategoryOrderByWithAggregationInput | VocabularyCategoryOrderByWithAggregationInput[]
    by: VocabularyCategoryScalarFieldEnum[] | VocabularyCategoryScalarFieldEnum
    having?: VocabularyCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VocabularyCategoryCountAggregateInputType | true
    _min?: VocabularyCategoryMinAggregateInputType
    _max?: VocabularyCategoryMaxAggregateInputType
  }

  export type VocabularyCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: VocabularyCategoryCountAggregateOutputType | null
    _min: VocabularyCategoryMinAggregateOutputType | null
    _max: VocabularyCategoryMaxAggregateOutputType | null
  }

  type GetVocabularyCategoryGroupByPayload<T extends VocabularyCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VocabularyCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VocabularyCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VocabularyCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], VocabularyCategoryGroupByOutputType[P]>
        }
      >
    >


  export type VocabularyCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vocabularies?: boolean | VocabularyCategory$vocabulariesArgs<ExtArgs>
    _count?: boolean | VocabularyCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vocabularyCategory"]>

  export type VocabularyCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vocabularyCategory"]>

  export type VocabularyCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VocabularyCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vocabularies?: boolean | VocabularyCategory$vocabulariesArgs<ExtArgs>
    _count?: boolean | VocabularyCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VocabularyCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VocabularyCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VocabularyCategory"
    objects: {
      vocabularies: Prisma.$VocabularyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vocabularyCategory"]>
    composites: {}
  }

  type VocabularyCategoryGetPayload<S extends boolean | null | undefined | VocabularyCategoryDefaultArgs> = $Result.GetResult<Prisma.$VocabularyCategoryPayload, S>

  type VocabularyCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VocabularyCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VocabularyCategoryCountAggregateInputType | true
    }

  export interface VocabularyCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VocabularyCategory'], meta: { name: 'VocabularyCategory' } }
    /**
     * Find zero or one VocabularyCategory that matches the filter.
     * @param {VocabularyCategoryFindUniqueArgs} args - Arguments to find a VocabularyCategory
     * @example
     * // Get one VocabularyCategory
     * const vocabularyCategory = await prisma.vocabularyCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VocabularyCategoryFindUniqueArgs>(args: SelectSubset<T, VocabularyCategoryFindUniqueArgs<ExtArgs>>): Prisma__VocabularyCategoryClient<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VocabularyCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VocabularyCategoryFindUniqueOrThrowArgs} args - Arguments to find a VocabularyCategory
     * @example
     * // Get one VocabularyCategory
     * const vocabularyCategory = await prisma.vocabularyCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VocabularyCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, VocabularyCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VocabularyCategoryClient<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VocabularyCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyCategoryFindFirstArgs} args - Arguments to find a VocabularyCategory
     * @example
     * // Get one VocabularyCategory
     * const vocabularyCategory = await prisma.vocabularyCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VocabularyCategoryFindFirstArgs>(args?: SelectSubset<T, VocabularyCategoryFindFirstArgs<ExtArgs>>): Prisma__VocabularyCategoryClient<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VocabularyCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyCategoryFindFirstOrThrowArgs} args - Arguments to find a VocabularyCategory
     * @example
     * // Get one VocabularyCategory
     * const vocabularyCategory = await prisma.vocabularyCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VocabularyCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, VocabularyCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VocabularyCategoryClient<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VocabularyCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VocabularyCategories
     * const vocabularyCategories = await prisma.vocabularyCategory.findMany()
     * 
     * // Get first 10 VocabularyCategories
     * const vocabularyCategories = await prisma.vocabularyCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vocabularyCategoryWithIdOnly = await prisma.vocabularyCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VocabularyCategoryFindManyArgs>(args?: SelectSubset<T, VocabularyCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VocabularyCategory.
     * @param {VocabularyCategoryCreateArgs} args - Arguments to create a VocabularyCategory.
     * @example
     * // Create one VocabularyCategory
     * const VocabularyCategory = await prisma.vocabularyCategory.create({
     *   data: {
     *     // ... data to create a VocabularyCategory
     *   }
     * })
     * 
     */
    create<T extends VocabularyCategoryCreateArgs>(args: SelectSubset<T, VocabularyCategoryCreateArgs<ExtArgs>>): Prisma__VocabularyCategoryClient<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VocabularyCategories.
     * @param {VocabularyCategoryCreateManyArgs} args - Arguments to create many VocabularyCategories.
     * @example
     * // Create many VocabularyCategories
     * const vocabularyCategory = await prisma.vocabularyCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VocabularyCategoryCreateManyArgs>(args?: SelectSubset<T, VocabularyCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VocabularyCategories and returns the data saved in the database.
     * @param {VocabularyCategoryCreateManyAndReturnArgs} args - Arguments to create many VocabularyCategories.
     * @example
     * // Create many VocabularyCategories
     * const vocabularyCategory = await prisma.vocabularyCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VocabularyCategories and only return the `id`
     * const vocabularyCategoryWithIdOnly = await prisma.vocabularyCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VocabularyCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, VocabularyCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VocabularyCategory.
     * @param {VocabularyCategoryDeleteArgs} args - Arguments to delete one VocabularyCategory.
     * @example
     * // Delete one VocabularyCategory
     * const VocabularyCategory = await prisma.vocabularyCategory.delete({
     *   where: {
     *     // ... filter to delete one VocabularyCategory
     *   }
     * })
     * 
     */
    delete<T extends VocabularyCategoryDeleteArgs>(args: SelectSubset<T, VocabularyCategoryDeleteArgs<ExtArgs>>): Prisma__VocabularyCategoryClient<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VocabularyCategory.
     * @param {VocabularyCategoryUpdateArgs} args - Arguments to update one VocabularyCategory.
     * @example
     * // Update one VocabularyCategory
     * const vocabularyCategory = await prisma.vocabularyCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VocabularyCategoryUpdateArgs>(args: SelectSubset<T, VocabularyCategoryUpdateArgs<ExtArgs>>): Prisma__VocabularyCategoryClient<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VocabularyCategories.
     * @param {VocabularyCategoryDeleteManyArgs} args - Arguments to filter VocabularyCategories to delete.
     * @example
     * // Delete a few VocabularyCategories
     * const { count } = await prisma.vocabularyCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VocabularyCategoryDeleteManyArgs>(args?: SelectSubset<T, VocabularyCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VocabularyCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VocabularyCategories
     * const vocabularyCategory = await prisma.vocabularyCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VocabularyCategoryUpdateManyArgs>(args: SelectSubset<T, VocabularyCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VocabularyCategory.
     * @param {VocabularyCategoryUpsertArgs} args - Arguments to update or create a VocabularyCategory.
     * @example
     * // Update or create a VocabularyCategory
     * const vocabularyCategory = await prisma.vocabularyCategory.upsert({
     *   create: {
     *     // ... data to create a VocabularyCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VocabularyCategory we want to update
     *   }
     * })
     */
    upsert<T extends VocabularyCategoryUpsertArgs>(args: SelectSubset<T, VocabularyCategoryUpsertArgs<ExtArgs>>): Prisma__VocabularyCategoryClient<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VocabularyCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyCategoryCountArgs} args - Arguments to filter VocabularyCategories to count.
     * @example
     * // Count the number of VocabularyCategories
     * const count = await prisma.vocabularyCategory.count({
     *   where: {
     *     // ... the filter for the VocabularyCategories we want to count
     *   }
     * })
    **/
    count<T extends VocabularyCategoryCountArgs>(
      args?: Subset<T, VocabularyCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VocabularyCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VocabularyCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VocabularyCategoryAggregateArgs>(args: Subset<T, VocabularyCategoryAggregateArgs>): Prisma.PrismaPromise<GetVocabularyCategoryAggregateType<T>>

    /**
     * Group by VocabularyCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VocabularyCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VocabularyCategoryGroupByArgs['orderBy'] }
        : { orderBy?: VocabularyCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VocabularyCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVocabularyCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VocabularyCategory model
   */
  readonly fields: VocabularyCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VocabularyCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VocabularyCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vocabularies<T extends VocabularyCategory$vocabulariesArgs<ExtArgs> = {}>(args?: Subset<T, VocabularyCategory$vocabulariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VocabularyCategory model
   */ 
  interface VocabularyCategoryFieldRefs {
    readonly id: FieldRef<"VocabularyCategory", 'String'>
    readonly name: FieldRef<"VocabularyCategory", 'String'>
    readonly description: FieldRef<"VocabularyCategory", 'String'>
    readonly isActive: FieldRef<"VocabularyCategory", 'Boolean'>
    readonly createdAt: FieldRef<"VocabularyCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"VocabularyCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VocabularyCategory findUnique
   */
  export type VocabularyCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyCategory to fetch.
     */
    where: VocabularyCategoryWhereUniqueInput
  }

  /**
   * VocabularyCategory findUniqueOrThrow
   */
  export type VocabularyCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyCategory to fetch.
     */
    where: VocabularyCategoryWhereUniqueInput
  }

  /**
   * VocabularyCategory findFirst
   */
  export type VocabularyCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyCategory to fetch.
     */
    where?: VocabularyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VocabularyCategories to fetch.
     */
    orderBy?: VocabularyCategoryOrderByWithRelationInput | VocabularyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VocabularyCategories.
     */
    cursor?: VocabularyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VocabularyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VocabularyCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VocabularyCategories.
     */
    distinct?: VocabularyCategoryScalarFieldEnum | VocabularyCategoryScalarFieldEnum[]
  }

  /**
   * VocabularyCategory findFirstOrThrow
   */
  export type VocabularyCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyCategory to fetch.
     */
    where?: VocabularyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VocabularyCategories to fetch.
     */
    orderBy?: VocabularyCategoryOrderByWithRelationInput | VocabularyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VocabularyCategories.
     */
    cursor?: VocabularyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VocabularyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VocabularyCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VocabularyCategories.
     */
    distinct?: VocabularyCategoryScalarFieldEnum | VocabularyCategoryScalarFieldEnum[]
  }

  /**
   * VocabularyCategory findMany
   */
  export type VocabularyCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyCategories to fetch.
     */
    where?: VocabularyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VocabularyCategories to fetch.
     */
    orderBy?: VocabularyCategoryOrderByWithRelationInput | VocabularyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VocabularyCategories.
     */
    cursor?: VocabularyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VocabularyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VocabularyCategories.
     */
    skip?: number
    distinct?: VocabularyCategoryScalarFieldEnum | VocabularyCategoryScalarFieldEnum[]
  }

  /**
   * VocabularyCategory create
   */
  export type VocabularyCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a VocabularyCategory.
     */
    data: XOR<VocabularyCategoryCreateInput, VocabularyCategoryUncheckedCreateInput>
  }

  /**
   * VocabularyCategory createMany
   */
  export type VocabularyCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VocabularyCategories.
     */
    data: VocabularyCategoryCreateManyInput | VocabularyCategoryCreateManyInput[]
  }

  /**
   * VocabularyCategory createManyAndReturn
   */
  export type VocabularyCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VocabularyCategories.
     */
    data: VocabularyCategoryCreateManyInput | VocabularyCategoryCreateManyInput[]
  }

  /**
   * VocabularyCategory update
   */
  export type VocabularyCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a VocabularyCategory.
     */
    data: XOR<VocabularyCategoryUpdateInput, VocabularyCategoryUncheckedUpdateInput>
    /**
     * Choose, which VocabularyCategory to update.
     */
    where: VocabularyCategoryWhereUniqueInput
  }

  /**
   * VocabularyCategory updateMany
   */
  export type VocabularyCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VocabularyCategories.
     */
    data: XOR<VocabularyCategoryUpdateManyMutationInput, VocabularyCategoryUncheckedUpdateManyInput>
    /**
     * Filter which VocabularyCategories to update
     */
    where?: VocabularyCategoryWhereInput
  }

  /**
   * VocabularyCategory upsert
   */
  export type VocabularyCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the VocabularyCategory to update in case it exists.
     */
    where: VocabularyCategoryWhereUniqueInput
    /**
     * In case the VocabularyCategory found by the `where` argument doesn't exist, create a new VocabularyCategory with this data.
     */
    create: XOR<VocabularyCategoryCreateInput, VocabularyCategoryUncheckedCreateInput>
    /**
     * In case the VocabularyCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VocabularyCategoryUpdateInput, VocabularyCategoryUncheckedUpdateInput>
  }

  /**
   * VocabularyCategory delete
   */
  export type VocabularyCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
    /**
     * Filter which VocabularyCategory to delete.
     */
    where: VocabularyCategoryWhereUniqueInput
  }

  /**
   * VocabularyCategory deleteMany
   */
  export type VocabularyCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VocabularyCategories to delete
     */
    where?: VocabularyCategoryWhereInput
  }

  /**
   * VocabularyCategory.vocabularies
   */
  export type VocabularyCategory$vocabulariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    where?: VocabularyWhereInput
    orderBy?: VocabularyOrderByWithRelationInput | VocabularyOrderByWithRelationInput[]
    cursor?: VocabularyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VocabularyScalarFieldEnum | VocabularyScalarFieldEnum[]
  }

  /**
   * VocabularyCategory without action
   */
  export type VocabularyCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyCategory
     */
    select?: VocabularyCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Vocabulary
   */

  export type AggregateVocabulary = {
    _count: VocabularyCountAggregateOutputType | null
    _avg: VocabularyAvgAggregateOutputType | null
    _sum: VocabularySumAggregateOutputType | null
    _min: VocabularyMinAggregateOutputType | null
    _max: VocabularyMaxAggregateOutputType | null
  }

  export type VocabularyAvgAggregateOutputType = {
    difficulty: number | null
    frequency: number | null
  }

  export type VocabularySumAggregateOutputType = {
    difficulty: number | null
    frequency: number | null
  }

  export type VocabularyMinAggregateOutputType = {
    id: string | null
    word: string | null
    pronunciation: string | null
    definition: string | null
    example: string | null
    difficulty: number | null
    frequency: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
  }

  export type VocabularyMaxAggregateOutputType = {
    id: string | null
    word: string | null
    pronunciation: string | null
    definition: string | null
    example: string | null
    difficulty: number | null
    frequency: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
  }

  export type VocabularyCountAggregateOutputType = {
    id: number
    word: number
    pronunciation: number
    definition: number
    example: number
    difficulty: number
    frequency: number
    isActive: number
    createdAt: number
    updatedAt: number
    categoryId: number
    _all: number
  }


  export type VocabularyAvgAggregateInputType = {
    difficulty?: true
    frequency?: true
  }

  export type VocabularySumAggregateInputType = {
    difficulty?: true
    frequency?: true
  }

  export type VocabularyMinAggregateInputType = {
    id?: true
    word?: true
    pronunciation?: true
    definition?: true
    example?: true
    difficulty?: true
    frequency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type VocabularyMaxAggregateInputType = {
    id?: true
    word?: true
    pronunciation?: true
    definition?: true
    example?: true
    difficulty?: true
    frequency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type VocabularyCountAggregateInputType = {
    id?: true
    word?: true
    pronunciation?: true
    definition?: true
    example?: true
    difficulty?: true
    frequency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    _all?: true
  }

  export type VocabularyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vocabulary to aggregate.
     */
    where?: VocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vocabularies to fetch.
     */
    orderBy?: VocabularyOrderByWithRelationInput | VocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vocabularies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vocabularies
    **/
    _count?: true | VocabularyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VocabularyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VocabularySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VocabularyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VocabularyMaxAggregateInputType
  }

  export type GetVocabularyAggregateType<T extends VocabularyAggregateArgs> = {
        [P in keyof T & keyof AggregateVocabulary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVocabulary[P]>
      : GetScalarType<T[P], AggregateVocabulary[P]>
  }




  export type VocabularyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VocabularyWhereInput
    orderBy?: VocabularyOrderByWithAggregationInput | VocabularyOrderByWithAggregationInput[]
    by: VocabularyScalarFieldEnum[] | VocabularyScalarFieldEnum
    having?: VocabularyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VocabularyCountAggregateInputType | true
    _avg?: VocabularyAvgAggregateInputType
    _sum?: VocabularySumAggregateInputType
    _min?: VocabularyMinAggregateInputType
    _max?: VocabularyMaxAggregateInputType
  }

  export type VocabularyGroupByOutputType = {
    id: string
    word: string
    pronunciation: string | null
    definition: string
    example: string | null
    difficulty: number
    frequency: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    categoryId: string
    _count: VocabularyCountAggregateOutputType | null
    _avg: VocabularyAvgAggregateOutputType | null
    _sum: VocabularySumAggregateOutputType | null
    _min: VocabularyMinAggregateOutputType | null
    _max: VocabularyMaxAggregateOutputType | null
  }

  type GetVocabularyGroupByPayload<T extends VocabularyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VocabularyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VocabularyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VocabularyGroupByOutputType[P]>
            : GetScalarType<T[P], VocabularyGroupByOutputType[P]>
        }
      >
    >


  export type VocabularySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    word?: boolean
    pronunciation?: boolean
    definition?: boolean
    example?: boolean
    difficulty?: boolean
    frequency?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    category?: boolean | VocabularyCategoryDefaultArgs<ExtArgs>
    userVocabularies?: boolean | Vocabulary$userVocabulariesArgs<ExtArgs>
    sessionRecords?: boolean | Vocabulary$sessionRecordsArgs<ExtArgs>
    _count?: boolean | VocabularyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vocabulary"]>

  export type VocabularySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    word?: boolean
    pronunciation?: boolean
    definition?: boolean
    example?: boolean
    difficulty?: boolean
    frequency?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    category?: boolean | VocabularyCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vocabulary"]>

  export type VocabularySelectScalar = {
    id?: boolean
    word?: boolean
    pronunciation?: boolean
    definition?: boolean
    example?: boolean
    difficulty?: boolean
    frequency?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
  }

  export type VocabularyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | VocabularyCategoryDefaultArgs<ExtArgs>
    userVocabularies?: boolean | Vocabulary$userVocabulariesArgs<ExtArgs>
    sessionRecords?: boolean | Vocabulary$sessionRecordsArgs<ExtArgs>
    _count?: boolean | VocabularyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VocabularyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | VocabularyCategoryDefaultArgs<ExtArgs>
  }

  export type $VocabularyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vocabulary"
    objects: {
      category: Prisma.$VocabularyCategoryPayload<ExtArgs>
      userVocabularies: Prisma.$UserVocabularyPayload<ExtArgs>[]
      sessionRecords: Prisma.$LearningSessionRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      word: string
      pronunciation: string | null
      definition: string
      example: string | null
      difficulty: number
      frequency: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      categoryId: string
    }, ExtArgs["result"]["vocabulary"]>
    composites: {}
  }

  type VocabularyGetPayload<S extends boolean | null | undefined | VocabularyDefaultArgs> = $Result.GetResult<Prisma.$VocabularyPayload, S>

  type VocabularyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VocabularyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VocabularyCountAggregateInputType | true
    }

  export interface VocabularyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vocabulary'], meta: { name: 'Vocabulary' } }
    /**
     * Find zero or one Vocabulary that matches the filter.
     * @param {VocabularyFindUniqueArgs} args - Arguments to find a Vocabulary
     * @example
     * // Get one Vocabulary
     * const vocabulary = await prisma.vocabulary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VocabularyFindUniqueArgs>(args: SelectSubset<T, VocabularyFindUniqueArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vocabulary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VocabularyFindUniqueOrThrowArgs} args - Arguments to find a Vocabulary
     * @example
     * // Get one Vocabulary
     * const vocabulary = await prisma.vocabulary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VocabularyFindUniqueOrThrowArgs>(args: SelectSubset<T, VocabularyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vocabulary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyFindFirstArgs} args - Arguments to find a Vocabulary
     * @example
     * // Get one Vocabulary
     * const vocabulary = await prisma.vocabulary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VocabularyFindFirstArgs>(args?: SelectSubset<T, VocabularyFindFirstArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vocabulary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyFindFirstOrThrowArgs} args - Arguments to find a Vocabulary
     * @example
     * // Get one Vocabulary
     * const vocabulary = await prisma.vocabulary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VocabularyFindFirstOrThrowArgs>(args?: SelectSubset<T, VocabularyFindFirstOrThrowArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vocabularies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vocabularies
     * const vocabularies = await prisma.vocabulary.findMany()
     * 
     * // Get first 10 Vocabularies
     * const vocabularies = await prisma.vocabulary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vocabularyWithIdOnly = await prisma.vocabulary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VocabularyFindManyArgs>(args?: SelectSubset<T, VocabularyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vocabulary.
     * @param {VocabularyCreateArgs} args - Arguments to create a Vocabulary.
     * @example
     * // Create one Vocabulary
     * const Vocabulary = await prisma.vocabulary.create({
     *   data: {
     *     // ... data to create a Vocabulary
     *   }
     * })
     * 
     */
    create<T extends VocabularyCreateArgs>(args: SelectSubset<T, VocabularyCreateArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vocabularies.
     * @param {VocabularyCreateManyArgs} args - Arguments to create many Vocabularies.
     * @example
     * // Create many Vocabularies
     * const vocabulary = await prisma.vocabulary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VocabularyCreateManyArgs>(args?: SelectSubset<T, VocabularyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vocabularies and returns the data saved in the database.
     * @param {VocabularyCreateManyAndReturnArgs} args - Arguments to create many Vocabularies.
     * @example
     * // Create many Vocabularies
     * const vocabulary = await prisma.vocabulary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vocabularies and only return the `id`
     * const vocabularyWithIdOnly = await prisma.vocabulary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VocabularyCreateManyAndReturnArgs>(args?: SelectSubset<T, VocabularyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vocabulary.
     * @param {VocabularyDeleteArgs} args - Arguments to delete one Vocabulary.
     * @example
     * // Delete one Vocabulary
     * const Vocabulary = await prisma.vocabulary.delete({
     *   where: {
     *     // ... filter to delete one Vocabulary
     *   }
     * })
     * 
     */
    delete<T extends VocabularyDeleteArgs>(args: SelectSubset<T, VocabularyDeleteArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vocabulary.
     * @param {VocabularyUpdateArgs} args - Arguments to update one Vocabulary.
     * @example
     * // Update one Vocabulary
     * const vocabulary = await prisma.vocabulary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VocabularyUpdateArgs>(args: SelectSubset<T, VocabularyUpdateArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vocabularies.
     * @param {VocabularyDeleteManyArgs} args - Arguments to filter Vocabularies to delete.
     * @example
     * // Delete a few Vocabularies
     * const { count } = await prisma.vocabulary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VocabularyDeleteManyArgs>(args?: SelectSubset<T, VocabularyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vocabularies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vocabularies
     * const vocabulary = await prisma.vocabulary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VocabularyUpdateManyArgs>(args: SelectSubset<T, VocabularyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vocabulary.
     * @param {VocabularyUpsertArgs} args - Arguments to update or create a Vocabulary.
     * @example
     * // Update or create a Vocabulary
     * const vocabulary = await prisma.vocabulary.upsert({
     *   create: {
     *     // ... data to create a Vocabulary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vocabulary we want to update
     *   }
     * })
     */
    upsert<T extends VocabularyUpsertArgs>(args: SelectSubset<T, VocabularyUpsertArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vocabularies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyCountArgs} args - Arguments to filter Vocabularies to count.
     * @example
     * // Count the number of Vocabularies
     * const count = await prisma.vocabulary.count({
     *   where: {
     *     // ... the filter for the Vocabularies we want to count
     *   }
     * })
    **/
    count<T extends VocabularyCountArgs>(
      args?: Subset<T, VocabularyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VocabularyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vocabulary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VocabularyAggregateArgs>(args: Subset<T, VocabularyAggregateArgs>): Prisma.PrismaPromise<GetVocabularyAggregateType<T>>

    /**
     * Group by Vocabulary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VocabularyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VocabularyGroupByArgs['orderBy'] }
        : { orderBy?: VocabularyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VocabularyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVocabularyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vocabulary model
   */
  readonly fields: VocabularyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vocabulary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VocabularyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends VocabularyCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VocabularyCategoryDefaultArgs<ExtArgs>>): Prisma__VocabularyCategoryClient<$Result.GetResult<Prisma.$VocabularyCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userVocabularies<T extends Vocabulary$userVocabulariesArgs<ExtArgs> = {}>(args?: Subset<T, Vocabulary$userVocabulariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "findMany"> | Null>
    sessionRecords<T extends Vocabulary$sessionRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Vocabulary$sessionRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vocabulary model
   */ 
  interface VocabularyFieldRefs {
    readonly id: FieldRef<"Vocabulary", 'String'>
    readonly word: FieldRef<"Vocabulary", 'String'>
    readonly pronunciation: FieldRef<"Vocabulary", 'String'>
    readonly definition: FieldRef<"Vocabulary", 'String'>
    readonly example: FieldRef<"Vocabulary", 'String'>
    readonly difficulty: FieldRef<"Vocabulary", 'Int'>
    readonly frequency: FieldRef<"Vocabulary", 'Int'>
    readonly isActive: FieldRef<"Vocabulary", 'Boolean'>
    readonly createdAt: FieldRef<"Vocabulary", 'DateTime'>
    readonly updatedAt: FieldRef<"Vocabulary", 'DateTime'>
    readonly categoryId: FieldRef<"Vocabulary", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vocabulary findUnique
   */
  export type VocabularyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    /**
     * Filter, which Vocabulary to fetch.
     */
    where: VocabularyWhereUniqueInput
  }

  /**
   * Vocabulary findUniqueOrThrow
   */
  export type VocabularyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    /**
     * Filter, which Vocabulary to fetch.
     */
    where: VocabularyWhereUniqueInput
  }

  /**
   * Vocabulary findFirst
   */
  export type VocabularyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    /**
     * Filter, which Vocabulary to fetch.
     */
    where?: VocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vocabularies to fetch.
     */
    orderBy?: VocabularyOrderByWithRelationInput | VocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vocabularies.
     */
    cursor?: VocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vocabularies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vocabularies.
     */
    distinct?: VocabularyScalarFieldEnum | VocabularyScalarFieldEnum[]
  }

  /**
   * Vocabulary findFirstOrThrow
   */
  export type VocabularyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    /**
     * Filter, which Vocabulary to fetch.
     */
    where?: VocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vocabularies to fetch.
     */
    orderBy?: VocabularyOrderByWithRelationInput | VocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vocabularies.
     */
    cursor?: VocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vocabularies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vocabularies.
     */
    distinct?: VocabularyScalarFieldEnum | VocabularyScalarFieldEnum[]
  }

  /**
   * Vocabulary findMany
   */
  export type VocabularyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    /**
     * Filter, which Vocabularies to fetch.
     */
    where?: VocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vocabularies to fetch.
     */
    orderBy?: VocabularyOrderByWithRelationInput | VocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vocabularies.
     */
    cursor?: VocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vocabularies.
     */
    skip?: number
    distinct?: VocabularyScalarFieldEnum | VocabularyScalarFieldEnum[]
  }

  /**
   * Vocabulary create
   */
  export type VocabularyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    /**
     * The data needed to create a Vocabulary.
     */
    data: XOR<VocabularyCreateInput, VocabularyUncheckedCreateInput>
  }

  /**
   * Vocabulary createMany
   */
  export type VocabularyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vocabularies.
     */
    data: VocabularyCreateManyInput | VocabularyCreateManyInput[]
  }

  /**
   * Vocabulary createManyAndReturn
   */
  export type VocabularyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vocabularies.
     */
    data: VocabularyCreateManyInput | VocabularyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vocabulary update
   */
  export type VocabularyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    /**
     * The data needed to update a Vocabulary.
     */
    data: XOR<VocabularyUpdateInput, VocabularyUncheckedUpdateInput>
    /**
     * Choose, which Vocabulary to update.
     */
    where: VocabularyWhereUniqueInput
  }

  /**
   * Vocabulary updateMany
   */
  export type VocabularyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vocabularies.
     */
    data: XOR<VocabularyUpdateManyMutationInput, VocabularyUncheckedUpdateManyInput>
    /**
     * Filter which Vocabularies to update
     */
    where?: VocabularyWhereInput
  }

  /**
   * Vocabulary upsert
   */
  export type VocabularyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    /**
     * The filter to search for the Vocabulary to update in case it exists.
     */
    where: VocabularyWhereUniqueInput
    /**
     * In case the Vocabulary found by the `where` argument doesn't exist, create a new Vocabulary with this data.
     */
    create: XOR<VocabularyCreateInput, VocabularyUncheckedCreateInput>
    /**
     * In case the Vocabulary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VocabularyUpdateInput, VocabularyUncheckedUpdateInput>
  }

  /**
   * Vocabulary delete
   */
  export type VocabularyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
    /**
     * Filter which Vocabulary to delete.
     */
    where: VocabularyWhereUniqueInput
  }

  /**
   * Vocabulary deleteMany
   */
  export type VocabularyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vocabularies to delete
     */
    where?: VocabularyWhereInput
  }

  /**
   * Vocabulary.userVocabularies
   */
  export type Vocabulary$userVocabulariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    where?: UserVocabularyWhereInput
    orderBy?: UserVocabularyOrderByWithRelationInput | UserVocabularyOrderByWithRelationInput[]
    cursor?: UserVocabularyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserVocabularyScalarFieldEnum | UserVocabularyScalarFieldEnum[]
  }

  /**
   * Vocabulary.sessionRecords
   */
  export type Vocabulary$sessionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    where?: LearningSessionRecordWhereInput
    orderBy?: LearningSessionRecordOrderByWithRelationInput | LearningSessionRecordOrderByWithRelationInput[]
    cursor?: LearningSessionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningSessionRecordScalarFieldEnum | LearningSessionRecordScalarFieldEnum[]
  }

  /**
   * Vocabulary without action
   */
  export type VocabularyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInclude<ExtArgs> | null
  }


  /**
   * Model UserVocabulary
   */

  export type AggregateUserVocabulary = {
    _count: UserVocabularyCountAggregateOutputType | null
    _avg: UserVocabularyAvgAggregateOutputType | null
    _sum: UserVocabularySumAggregateOutputType | null
    _min: UserVocabularyMinAggregateOutputType | null
    _max: UserVocabularyMaxAggregateOutputType | null
  }

  export type UserVocabularyAvgAggregateOutputType = {
    masteryLevel: number | null
    reviewCount: number | null
    correctCount: number | null
    consecutiveCorrect: number | null
  }

  export type UserVocabularySumAggregateOutputType = {
    masteryLevel: number | null
    reviewCount: number | null
    correctCount: number | null
    consecutiveCorrect: number | null
  }

  export type UserVocabularyMinAggregateOutputType = {
    id: string | null
    masteryLevel: number | null
    reviewCount: number | null
    correctCount: number | null
    consecutiveCorrect: number | null
    nextReviewAt: Date | null
    lastReviewAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    vocabularyId: string | null
  }

  export type UserVocabularyMaxAggregateOutputType = {
    id: string | null
    masteryLevel: number | null
    reviewCount: number | null
    correctCount: number | null
    consecutiveCorrect: number | null
    nextReviewAt: Date | null
    lastReviewAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    vocabularyId: string | null
  }

  export type UserVocabularyCountAggregateOutputType = {
    id: number
    masteryLevel: number
    reviewCount: number
    correctCount: number
    consecutiveCorrect: number
    nextReviewAt: number
    lastReviewAt: number
    createdAt: number
    updatedAt: number
    userId: number
    vocabularyId: number
    _all: number
  }


  export type UserVocabularyAvgAggregateInputType = {
    masteryLevel?: true
    reviewCount?: true
    correctCount?: true
    consecutiveCorrect?: true
  }

  export type UserVocabularySumAggregateInputType = {
    masteryLevel?: true
    reviewCount?: true
    correctCount?: true
    consecutiveCorrect?: true
  }

  export type UserVocabularyMinAggregateInputType = {
    id?: true
    masteryLevel?: true
    reviewCount?: true
    correctCount?: true
    consecutiveCorrect?: true
    nextReviewAt?: true
    lastReviewAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    vocabularyId?: true
  }

  export type UserVocabularyMaxAggregateInputType = {
    id?: true
    masteryLevel?: true
    reviewCount?: true
    correctCount?: true
    consecutiveCorrect?: true
    nextReviewAt?: true
    lastReviewAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    vocabularyId?: true
  }

  export type UserVocabularyCountAggregateInputType = {
    id?: true
    masteryLevel?: true
    reviewCount?: true
    correctCount?: true
    consecutiveCorrect?: true
    nextReviewAt?: true
    lastReviewAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    vocabularyId?: true
    _all?: true
  }

  export type UserVocabularyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserVocabulary to aggregate.
     */
    where?: UserVocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserVocabularies to fetch.
     */
    orderBy?: UserVocabularyOrderByWithRelationInput | UserVocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserVocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserVocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserVocabularies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserVocabularies
    **/
    _count?: true | UserVocabularyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserVocabularyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserVocabularySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserVocabularyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserVocabularyMaxAggregateInputType
  }

  export type GetUserVocabularyAggregateType<T extends UserVocabularyAggregateArgs> = {
        [P in keyof T & keyof AggregateUserVocabulary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserVocabulary[P]>
      : GetScalarType<T[P], AggregateUserVocabulary[P]>
  }




  export type UserVocabularyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserVocabularyWhereInput
    orderBy?: UserVocabularyOrderByWithAggregationInput | UserVocabularyOrderByWithAggregationInput[]
    by: UserVocabularyScalarFieldEnum[] | UserVocabularyScalarFieldEnum
    having?: UserVocabularyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserVocabularyCountAggregateInputType | true
    _avg?: UserVocabularyAvgAggregateInputType
    _sum?: UserVocabularySumAggregateInputType
    _min?: UserVocabularyMinAggregateInputType
    _max?: UserVocabularyMaxAggregateInputType
  }

  export type UserVocabularyGroupByOutputType = {
    id: string
    masteryLevel: number
    reviewCount: number
    correctCount: number
    consecutiveCorrect: number
    nextReviewAt: Date
    lastReviewAt: Date | null
    createdAt: Date
    updatedAt: Date
    userId: string
    vocabularyId: string
    _count: UserVocabularyCountAggregateOutputType | null
    _avg: UserVocabularyAvgAggregateOutputType | null
    _sum: UserVocabularySumAggregateOutputType | null
    _min: UserVocabularyMinAggregateOutputType | null
    _max: UserVocabularyMaxAggregateOutputType | null
  }

  type GetUserVocabularyGroupByPayload<T extends UserVocabularyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserVocabularyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserVocabularyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserVocabularyGroupByOutputType[P]>
            : GetScalarType<T[P], UserVocabularyGroupByOutputType[P]>
        }
      >
    >


  export type UserVocabularySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    masteryLevel?: boolean
    reviewCount?: boolean
    correctCount?: boolean
    consecutiveCorrect?: boolean
    nextReviewAt?: boolean
    lastReviewAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    vocabularyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vocabulary?: boolean | VocabularyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userVocabulary"]>

  export type UserVocabularySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    masteryLevel?: boolean
    reviewCount?: boolean
    correctCount?: boolean
    consecutiveCorrect?: boolean
    nextReviewAt?: boolean
    lastReviewAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    vocabularyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vocabulary?: boolean | VocabularyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userVocabulary"]>

  export type UserVocabularySelectScalar = {
    id?: boolean
    masteryLevel?: boolean
    reviewCount?: boolean
    correctCount?: boolean
    consecutiveCorrect?: boolean
    nextReviewAt?: boolean
    lastReviewAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    vocabularyId?: boolean
  }

  export type UserVocabularyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vocabulary?: boolean | VocabularyDefaultArgs<ExtArgs>
  }
  export type UserVocabularyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vocabulary?: boolean | VocabularyDefaultArgs<ExtArgs>
  }

  export type $UserVocabularyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserVocabulary"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vocabulary: Prisma.$VocabularyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      masteryLevel: number
      reviewCount: number
      correctCount: number
      consecutiveCorrect: number
      nextReviewAt: Date
      lastReviewAt: Date | null
      createdAt: Date
      updatedAt: Date
      userId: string
      vocabularyId: string
    }, ExtArgs["result"]["userVocabulary"]>
    composites: {}
  }

  type UserVocabularyGetPayload<S extends boolean | null | undefined | UserVocabularyDefaultArgs> = $Result.GetResult<Prisma.$UserVocabularyPayload, S>

  type UserVocabularyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserVocabularyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserVocabularyCountAggregateInputType | true
    }

  export interface UserVocabularyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserVocabulary'], meta: { name: 'UserVocabulary' } }
    /**
     * Find zero or one UserVocabulary that matches the filter.
     * @param {UserVocabularyFindUniqueArgs} args - Arguments to find a UserVocabulary
     * @example
     * // Get one UserVocabulary
     * const userVocabulary = await prisma.userVocabulary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserVocabularyFindUniqueArgs>(args: SelectSubset<T, UserVocabularyFindUniqueArgs<ExtArgs>>): Prisma__UserVocabularyClient<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserVocabulary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserVocabularyFindUniqueOrThrowArgs} args - Arguments to find a UserVocabulary
     * @example
     * // Get one UserVocabulary
     * const userVocabulary = await prisma.userVocabulary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserVocabularyFindUniqueOrThrowArgs>(args: SelectSubset<T, UserVocabularyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserVocabularyClient<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserVocabulary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVocabularyFindFirstArgs} args - Arguments to find a UserVocabulary
     * @example
     * // Get one UserVocabulary
     * const userVocabulary = await prisma.userVocabulary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserVocabularyFindFirstArgs>(args?: SelectSubset<T, UserVocabularyFindFirstArgs<ExtArgs>>): Prisma__UserVocabularyClient<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserVocabulary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVocabularyFindFirstOrThrowArgs} args - Arguments to find a UserVocabulary
     * @example
     * // Get one UserVocabulary
     * const userVocabulary = await prisma.userVocabulary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserVocabularyFindFirstOrThrowArgs>(args?: SelectSubset<T, UserVocabularyFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserVocabularyClient<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserVocabularies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVocabularyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserVocabularies
     * const userVocabularies = await prisma.userVocabulary.findMany()
     * 
     * // Get first 10 UserVocabularies
     * const userVocabularies = await prisma.userVocabulary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userVocabularyWithIdOnly = await prisma.userVocabulary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserVocabularyFindManyArgs>(args?: SelectSubset<T, UserVocabularyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserVocabulary.
     * @param {UserVocabularyCreateArgs} args - Arguments to create a UserVocabulary.
     * @example
     * // Create one UserVocabulary
     * const UserVocabulary = await prisma.userVocabulary.create({
     *   data: {
     *     // ... data to create a UserVocabulary
     *   }
     * })
     * 
     */
    create<T extends UserVocabularyCreateArgs>(args: SelectSubset<T, UserVocabularyCreateArgs<ExtArgs>>): Prisma__UserVocabularyClient<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserVocabularies.
     * @param {UserVocabularyCreateManyArgs} args - Arguments to create many UserVocabularies.
     * @example
     * // Create many UserVocabularies
     * const userVocabulary = await prisma.userVocabulary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserVocabularyCreateManyArgs>(args?: SelectSubset<T, UserVocabularyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserVocabularies and returns the data saved in the database.
     * @param {UserVocabularyCreateManyAndReturnArgs} args - Arguments to create many UserVocabularies.
     * @example
     * // Create many UserVocabularies
     * const userVocabulary = await prisma.userVocabulary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserVocabularies and only return the `id`
     * const userVocabularyWithIdOnly = await prisma.userVocabulary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserVocabularyCreateManyAndReturnArgs>(args?: SelectSubset<T, UserVocabularyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserVocabulary.
     * @param {UserVocabularyDeleteArgs} args - Arguments to delete one UserVocabulary.
     * @example
     * // Delete one UserVocabulary
     * const UserVocabulary = await prisma.userVocabulary.delete({
     *   where: {
     *     // ... filter to delete one UserVocabulary
     *   }
     * })
     * 
     */
    delete<T extends UserVocabularyDeleteArgs>(args: SelectSubset<T, UserVocabularyDeleteArgs<ExtArgs>>): Prisma__UserVocabularyClient<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserVocabulary.
     * @param {UserVocabularyUpdateArgs} args - Arguments to update one UserVocabulary.
     * @example
     * // Update one UserVocabulary
     * const userVocabulary = await prisma.userVocabulary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserVocabularyUpdateArgs>(args: SelectSubset<T, UserVocabularyUpdateArgs<ExtArgs>>): Prisma__UserVocabularyClient<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserVocabularies.
     * @param {UserVocabularyDeleteManyArgs} args - Arguments to filter UserVocabularies to delete.
     * @example
     * // Delete a few UserVocabularies
     * const { count } = await prisma.userVocabulary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserVocabularyDeleteManyArgs>(args?: SelectSubset<T, UserVocabularyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserVocabularies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVocabularyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserVocabularies
     * const userVocabulary = await prisma.userVocabulary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserVocabularyUpdateManyArgs>(args: SelectSubset<T, UserVocabularyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserVocabulary.
     * @param {UserVocabularyUpsertArgs} args - Arguments to update or create a UserVocabulary.
     * @example
     * // Update or create a UserVocabulary
     * const userVocabulary = await prisma.userVocabulary.upsert({
     *   create: {
     *     // ... data to create a UserVocabulary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserVocabulary we want to update
     *   }
     * })
     */
    upsert<T extends UserVocabularyUpsertArgs>(args: SelectSubset<T, UserVocabularyUpsertArgs<ExtArgs>>): Prisma__UserVocabularyClient<$Result.GetResult<Prisma.$UserVocabularyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserVocabularies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVocabularyCountArgs} args - Arguments to filter UserVocabularies to count.
     * @example
     * // Count the number of UserVocabularies
     * const count = await prisma.userVocabulary.count({
     *   where: {
     *     // ... the filter for the UserVocabularies we want to count
     *   }
     * })
    **/
    count<T extends UserVocabularyCountArgs>(
      args?: Subset<T, UserVocabularyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserVocabularyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserVocabulary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVocabularyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserVocabularyAggregateArgs>(args: Subset<T, UserVocabularyAggregateArgs>): Prisma.PrismaPromise<GetUserVocabularyAggregateType<T>>

    /**
     * Group by UserVocabulary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVocabularyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserVocabularyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserVocabularyGroupByArgs['orderBy'] }
        : { orderBy?: UserVocabularyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserVocabularyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserVocabularyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserVocabulary model
   */
  readonly fields: UserVocabularyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserVocabulary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserVocabularyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vocabulary<T extends VocabularyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VocabularyDefaultArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserVocabulary model
   */ 
  interface UserVocabularyFieldRefs {
    readonly id: FieldRef<"UserVocabulary", 'String'>
    readonly masteryLevel: FieldRef<"UserVocabulary", 'Int'>
    readonly reviewCount: FieldRef<"UserVocabulary", 'Int'>
    readonly correctCount: FieldRef<"UserVocabulary", 'Int'>
    readonly consecutiveCorrect: FieldRef<"UserVocabulary", 'Int'>
    readonly nextReviewAt: FieldRef<"UserVocabulary", 'DateTime'>
    readonly lastReviewAt: FieldRef<"UserVocabulary", 'DateTime'>
    readonly createdAt: FieldRef<"UserVocabulary", 'DateTime'>
    readonly updatedAt: FieldRef<"UserVocabulary", 'DateTime'>
    readonly userId: FieldRef<"UserVocabulary", 'String'>
    readonly vocabularyId: FieldRef<"UserVocabulary", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserVocabulary findUnique
   */
  export type UserVocabularyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    /**
     * Filter, which UserVocabulary to fetch.
     */
    where: UserVocabularyWhereUniqueInput
  }

  /**
   * UserVocabulary findUniqueOrThrow
   */
  export type UserVocabularyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    /**
     * Filter, which UserVocabulary to fetch.
     */
    where: UserVocabularyWhereUniqueInput
  }

  /**
   * UserVocabulary findFirst
   */
  export type UserVocabularyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    /**
     * Filter, which UserVocabulary to fetch.
     */
    where?: UserVocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserVocabularies to fetch.
     */
    orderBy?: UserVocabularyOrderByWithRelationInput | UserVocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserVocabularies.
     */
    cursor?: UserVocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserVocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserVocabularies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserVocabularies.
     */
    distinct?: UserVocabularyScalarFieldEnum | UserVocabularyScalarFieldEnum[]
  }

  /**
   * UserVocabulary findFirstOrThrow
   */
  export type UserVocabularyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    /**
     * Filter, which UserVocabulary to fetch.
     */
    where?: UserVocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserVocabularies to fetch.
     */
    orderBy?: UserVocabularyOrderByWithRelationInput | UserVocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserVocabularies.
     */
    cursor?: UserVocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserVocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserVocabularies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserVocabularies.
     */
    distinct?: UserVocabularyScalarFieldEnum | UserVocabularyScalarFieldEnum[]
  }

  /**
   * UserVocabulary findMany
   */
  export type UserVocabularyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    /**
     * Filter, which UserVocabularies to fetch.
     */
    where?: UserVocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserVocabularies to fetch.
     */
    orderBy?: UserVocabularyOrderByWithRelationInput | UserVocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserVocabularies.
     */
    cursor?: UserVocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserVocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserVocabularies.
     */
    skip?: number
    distinct?: UserVocabularyScalarFieldEnum | UserVocabularyScalarFieldEnum[]
  }

  /**
   * UserVocabulary create
   */
  export type UserVocabularyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    /**
     * The data needed to create a UserVocabulary.
     */
    data: XOR<UserVocabularyCreateInput, UserVocabularyUncheckedCreateInput>
  }

  /**
   * UserVocabulary createMany
   */
  export type UserVocabularyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserVocabularies.
     */
    data: UserVocabularyCreateManyInput | UserVocabularyCreateManyInput[]
  }

  /**
   * UserVocabulary createManyAndReturn
   */
  export type UserVocabularyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserVocabularies.
     */
    data: UserVocabularyCreateManyInput | UserVocabularyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserVocabulary update
   */
  export type UserVocabularyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    /**
     * The data needed to update a UserVocabulary.
     */
    data: XOR<UserVocabularyUpdateInput, UserVocabularyUncheckedUpdateInput>
    /**
     * Choose, which UserVocabulary to update.
     */
    where: UserVocabularyWhereUniqueInput
  }

  /**
   * UserVocabulary updateMany
   */
  export type UserVocabularyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserVocabularies.
     */
    data: XOR<UserVocabularyUpdateManyMutationInput, UserVocabularyUncheckedUpdateManyInput>
    /**
     * Filter which UserVocabularies to update
     */
    where?: UserVocabularyWhereInput
  }

  /**
   * UserVocabulary upsert
   */
  export type UserVocabularyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    /**
     * The filter to search for the UserVocabulary to update in case it exists.
     */
    where: UserVocabularyWhereUniqueInput
    /**
     * In case the UserVocabulary found by the `where` argument doesn't exist, create a new UserVocabulary with this data.
     */
    create: XOR<UserVocabularyCreateInput, UserVocabularyUncheckedCreateInput>
    /**
     * In case the UserVocabulary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserVocabularyUpdateInput, UserVocabularyUncheckedUpdateInput>
  }

  /**
   * UserVocabulary delete
   */
  export type UserVocabularyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
    /**
     * Filter which UserVocabulary to delete.
     */
    where: UserVocabularyWhereUniqueInput
  }

  /**
   * UserVocabulary deleteMany
   */
  export type UserVocabularyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserVocabularies to delete
     */
    where?: UserVocabularyWhereInput
  }

  /**
   * UserVocabulary without action
   */
  export type UserVocabularyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVocabulary
     */
    select?: UserVocabularySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVocabularyInclude<ExtArgs> | null
  }


  /**
   * Model LearningSession
   */

  export type AggregateLearningSession = {
    _count: LearningSessionCountAggregateOutputType | null
    _avg: LearningSessionAvgAggregateOutputType | null
    _sum: LearningSessionSumAggregateOutputType | null
    _min: LearningSessionMinAggregateOutputType | null
    _max: LearningSessionMaxAggregateOutputType | null
  }

  export type LearningSessionAvgAggregateOutputType = {
    totalWords: number | null
    correctAnswers: number | null
    timeSpent: number | null
  }

  export type LearningSessionSumAggregateOutputType = {
    totalWords: number | null
    correctAnswers: number | null
    timeSpent: number | null
  }

  export type LearningSessionMinAggregateOutputType = {
    id: string | null
    sessionType: string | null
    startTime: Date | null
    endTime: Date | null
    totalWords: number | null
    correctAnswers: number | null
    timeSpent: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type LearningSessionMaxAggregateOutputType = {
    id: string | null
    sessionType: string | null
    startTime: Date | null
    endTime: Date | null
    totalWords: number | null
    correctAnswers: number | null
    timeSpent: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type LearningSessionCountAggregateOutputType = {
    id: number
    sessionType: number
    startTime: number
    endTime: number
    totalWords: number
    correctAnswers: number
    timeSpent: number
    isActive: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type LearningSessionAvgAggregateInputType = {
    totalWords?: true
    correctAnswers?: true
    timeSpent?: true
  }

  export type LearningSessionSumAggregateInputType = {
    totalWords?: true
    correctAnswers?: true
    timeSpent?: true
  }

  export type LearningSessionMinAggregateInputType = {
    id?: true
    sessionType?: true
    startTime?: true
    endTime?: true
    totalWords?: true
    correctAnswers?: true
    timeSpent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type LearningSessionMaxAggregateInputType = {
    id?: true
    sessionType?: true
    startTime?: true
    endTime?: true
    totalWords?: true
    correctAnswers?: true
    timeSpent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type LearningSessionCountAggregateInputType = {
    id?: true
    sessionType?: true
    startTime?: true
    endTime?: true
    totalWords?: true
    correctAnswers?: true
    timeSpent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type LearningSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningSession to aggregate.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningSessions
    **/
    _count?: true | LearningSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningSessionMaxAggregateInputType
  }

  export type GetLearningSessionAggregateType<T extends LearningSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningSession[P]>
      : GetScalarType<T[P], AggregateLearningSession[P]>
  }




  export type LearningSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionWhereInput
    orderBy?: LearningSessionOrderByWithAggregationInput | LearningSessionOrderByWithAggregationInput[]
    by: LearningSessionScalarFieldEnum[] | LearningSessionScalarFieldEnum
    having?: LearningSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningSessionCountAggregateInputType | true
    _avg?: LearningSessionAvgAggregateInputType
    _sum?: LearningSessionSumAggregateInputType
    _min?: LearningSessionMinAggregateInputType
    _max?: LearningSessionMaxAggregateInputType
  }

  export type LearningSessionGroupByOutputType = {
    id: string
    sessionType: string
    startTime: Date
    endTime: Date | null
    totalWords: number
    correctAnswers: number
    timeSpent: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: LearningSessionCountAggregateOutputType | null
    _avg: LearningSessionAvgAggregateOutputType | null
    _sum: LearningSessionSumAggregateOutputType | null
    _min: LearningSessionMinAggregateOutputType | null
    _max: LearningSessionMaxAggregateOutputType | null
  }

  type GetLearningSessionGroupByPayload<T extends LearningSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningSessionGroupByOutputType[P]>
            : GetScalarType<T[P], LearningSessionGroupByOutputType[P]>
        }
      >
    >


  export type LearningSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionType?: boolean
    startTime?: boolean
    endTime?: boolean
    totalWords?: boolean
    correctAnswers?: boolean
    timeSpent?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sessionRecords?: boolean | LearningSession$sessionRecordsArgs<ExtArgs>
    _count?: boolean | LearningSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningSession"]>

  export type LearningSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionType?: boolean
    startTime?: boolean
    endTime?: boolean
    totalWords?: boolean
    correctAnswers?: boolean
    timeSpent?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningSession"]>

  export type LearningSessionSelectScalar = {
    id?: boolean
    sessionType?: boolean
    startTime?: boolean
    endTime?: boolean
    totalWords?: boolean
    correctAnswers?: boolean
    timeSpent?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type LearningSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sessionRecords?: boolean | LearningSession$sessionRecordsArgs<ExtArgs>
    _count?: boolean | LearningSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearningSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LearningSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      sessionRecords: Prisma.$LearningSessionRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionType: string
      startTime: Date
      endTime: Date | null
      totalWords: number
      correctAnswers: number
      timeSpent: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["learningSession"]>
    composites: {}
  }

  type LearningSessionGetPayload<S extends boolean | null | undefined | LearningSessionDefaultArgs> = $Result.GetResult<Prisma.$LearningSessionPayload, S>

  type LearningSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearningSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearningSessionCountAggregateInputType | true
    }

  export interface LearningSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningSession'], meta: { name: 'LearningSession' } }
    /**
     * Find zero or one LearningSession that matches the filter.
     * @param {LearningSessionFindUniqueArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningSessionFindUniqueArgs>(args: SelectSubset<T, LearningSessionFindUniqueArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearningSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearningSessionFindUniqueOrThrowArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearningSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionFindFirstArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningSessionFindFirstArgs>(args?: SelectSubset<T, LearningSessionFindFirstArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearningSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionFindFirstOrThrowArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearningSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningSessions
     * const learningSessions = await prisma.learningSession.findMany()
     * 
     * // Get first 10 LearningSessions
     * const learningSessions = await prisma.learningSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningSessionWithIdOnly = await prisma.learningSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningSessionFindManyArgs>(args?: SelectSubset<T, LearningSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearningSession.
     * @param {LearningSessionCreateArgs} args - Arguments to create a LearningSession.
     * @example
     * // Create one LearningSession
     * const LearningSession = await prisma.learningSession.create({
     *   data: {
     *     // ... data to create a LearningSession
     *   }
     * })
     * 
     */
    create<T extends LearningSessionCreateArgs>(args: SelectSubset<T, LearningSessionCreateArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearningSessions.
     * @param {LearningSessionCreateManyArgs} args - Arguments to create many LearningSessions.
     * @example
     * // Create many LearningSessions
     * const learningSession = await prisma.learningSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningSessionCreateManyArgs>(args?: SelectSubset<T, LearningSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningSessions and returns the data saved in the database.
     * @param {LearningSessionCreateManyAndReturnArgs} args - Arguments to create many LearningSessions.
     * @example
     * // Create many LearningSessions
     * const learningSession = await prisma.learningSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningSessions and only return the `id`
     * const learningSessionWithIdOnly = await prisma.learningSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearningSession.
     * @param {LearningSessionDeleteArgs} args - Arguments to delete one LearningSession.
     * @example
     * // Delete one LearningSession
     * const LearningSession = await prisma.learningSession.delete({
     *   where: {
     *     // ... filter to delete one LearningSession
     *   }
     * })
     * 
     */
    delete<T extends LearningSessionDeleteArgs>(args: SelectSubset<T, LearningSessionDeleteArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearningSession.
     * @param {LearningSessionUpdateArgs} args - Arguments to update one LearningSession.
     * @example
     * // Update one LearningSession
     * const learningSession = await prisma.learningSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningSessionUpdateArgs>(args: SelectSubset<T, LearningSessionUpdateArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearningSessions.
     * @param {LearningSessionDeleteManyArgs} args - Arguments to filter LearningSessions to delete.
     * @example
     * // Delete a few LearningSessions
     * const { count } = await prisma.learningSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningSessionDeleteManyArgs>(args?: SelectSubset<T, LearningSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningSessions
     * const learningSession = await prisma.learningSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningSessionUpdateManyArgs>(args: SelectSubset<T, LearningSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningSession.
     * @param {LearningSessionUpsertArgs} args - Arguments to update or create a LearningSession.
     * @example
     * // Update or create a LearningSession
     * const learningSession = await prisma.learningSession.upsert({
     *   create: {
     *     // ... data to create a LearningSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningSession we want to update
     *   }
     * })
     */
    upsert<T extends LearningSessionUpsertArgs>(args: SelectSubset<T, LearningSessionUpsertArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionCountArgs} args - Arguments to filter LearningSessions to count.
     * @example
     * // Count the number of LearningSessions
     * const count = await prisma.learningSession.count({
     *   where: {
     *     // ... the filter for the LearningSessions we want to count
     *   }
     * })
    **/
    count<T extends LearningSessionCountArgs>(
      args?: Subset<T, LearningSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningSessionAggregateArgs>(args: Subset<T, LearningSessionAggregateArgs>): Prisma.PrismaPromise<GetLearningSessionAggregateType<T>>

    /**
     * Group by LearningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningSessionGroupByArgs['orderBy'] }
        : { orderBy?: LearningSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningSession model
   */
  readonly fields: LearningSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sessionRecords<T extends LearningSession$sessionRecordsArgs<ExtArgs> = {}>(args?: Subset<T, LearningSession$sessionRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningSession model
   */ 
  interface LearningSessionFieldRefs {
    readonly id: FieldRef<"LearningSession", 'String'>
    readonly sessionType: FieldRef<"LearningSession", 'String'>
    readonly startTime: FieldRef<"LearningSession", 'DateTime'>
    readonly endTime: FieldRef<"LearningSession", 'DateTime'>
    readonly totalWords: FieldRef<"LearningSession", 'Int'>
    readonly correctAnswers: FieldRef<"LearningSession", 'Int'>
    readonly timeSpent: FieldRef<"LearningSession", 'Int'>
    readonly isActive: FieldRef<"LearningSession", 'Boolean'>
    readonly createdAt: FieldRef<"LearningSession", 'DateTime'>
    readonly updatedAt: FieldRef<"LearningSession", 'DateTime'>
    readonly userId: FieldRef<"LearningSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LearningSession findUnique
   */
  export type LearningSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession findUniqueOrThrow
   */
  export type LearningSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession findFirst
   */
  export type LearningSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningSessions.
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningSessions.
     */
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * LearningSession findFirstOrThrow
   */
  export type LearningSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningSessions.
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningSessions.
     */
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * LearningSession findMany
   */
  export type LearningSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSessions to fetch.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningSessions.
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * LearningSession create
   */
  export type LearningSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningSession.
     */
    data: XOR<LearningSessionCreateInput, LearningSessionUncheckedCreateInput>
  }

  /**
   * LearningSession createMany
   */
  export type LearningSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningSessions.
     */
    data: LearningSessionCreateManyInput | LearningSessionCreateManyInput[]
  }

  /**
   * LearningSession createManyAndReturn
   */
  export type LearningSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearningSessions.
     */
    data: LearningSessionCreateManyInput | LearningSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningSession update
   */
  export type LearningSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningSession.
     */
    data: XOR<LearningSessionUpdateInput, LearningSessionUncheckedUpdateInput>
    /**
     * Choose, which LearningSession to update.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession updateMany
   */
  export type LearningSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningSessions.
     */
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyInput>
    /**
     * Filter which LearningSessions to update
     */
    where?: LearningSessionWhereInput
  }

  /**
   * LearningSession upsert
   */
  export type LearningSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningSession to update in case it exists.
     */
    where: LearningSessionWhereUniqueInput
    /**
     * In case the LearningSession found by the `where` argument doesn't exist, create a new LearningSession with this data.
     */
    create: XOR<LearningSessionCreateInput, LearningSessionUncheckedCreateInput>
    /**
     * In case the LearningSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningSessionUpdateInput, LearningSessionUncheckedUpdateInput>
  }

  /**
   * LearningSession delete
   */
  export type LearningSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter which LearningSession to delete.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession deleteMany
   */
  export type LearningSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningSessions to delete
     */
    where?: LearningSessionWhereInput
  }

  /**
   * LearningSession.sessionRecords
   */
  export type LearningSession$sessionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    where?: LearningSessionRecordWhereInput
    orderBy?: LearningSessionRecordOrderByWithRelationInput | LearningSessionRecordOrderByWithRelationInput[]
    cursor?: LearningSessionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningSessionRecordScalarFieldEnum | LearningSessionRecordScalarFieldEnum[]
  }

  /**
   * LearningSession without action
   */
  export type LearningSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
  }


  /**
   * Model LearningSessionRecord
   */

  export type AggregateLearningSessionRecord = {
    _count: LearningSessionRecordCountAggregateOutputType | null
    _avg: LearningSessionRecordAvgAggregateOutputType | null
    _sum: LearningSessionRecordSumAggregateOutputType | null
    _min: LearningSessionRecordMinAggregateOutputType | null
    _max: LearningSessionRecordMaxAggregateOutputType | null
  }

  export type LearningSessionRecordAvgAggregateOutputType = {
    responseTime: number | null
    difficulty: number | null
  }

  export type LearningSessionRecordSumAggregateOutputType = {
    responseTime: number | null
    difficulty: number | null
  }

  export type LearningSessionRecordMinAggregateOutputType = {
    id: string | null
    isCorrect: boolean | null
    responseTime: number | null
    difficulty: number | null
    createdAt: Date | null
    sessionId: string | null
    vocabularyId: string | null
  }

  export type LearningSessionRecordMaxAggregateOutputType = {
    id: string | null
    isCorrect: boolean | null
    responseTime: number | null
    difficulty: number | null
    createdAt: Date | null
    sessionId: string | null
    vocabularyId: string | null
  }

  export type LearningSessionRecordCountAggregateOutputType = {
    id: number
    isCorrect: number
    responseTime: number
    difficulty: number
    createdAt: number
    sessionId: number
    vocabularyId: number
    _all: number
  }


  export type LearningSessionRecordAvgAggregateInputType = {
    responseTime?: true
    difficulty?: true
  }

  export type LearningSessionRecordSumAggregateInputType = {
    responseTime?: true
    difficulty?: true
  }

  export type LearningSessionRecordMinAggregateInputType = {
    id?: true
    isCorrect?: true
    responseTime?: true
    difficulty?: true
    createdAt?: true
    sessionId?: true
    vocabularyId?: true
  }

  export type LearningSessionRecordMaxAggregateInputType = {
    id?: true
    isCorrect?: true
    responseTime?: true
    difficulty?: true
    createdAt?: true
    sessionId?: true
    vocabularyId?: true
  }

  export type LearningSessionRecordCountAggregateInputType = {
    id?: true
    isCorrect?: true
    responseTime?: true
    difficulty?: true
    createdAt?: true
    sessionId?: true
    vocabularyId?: true
    _all?: true
  }

  export type LearningSessionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningSessionRecord to aggregate.
     */
    where?: LearningSessionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessionRecords to fetch.
     */
    orderBy?: LearningSessionRecordOrderByWithRelationInput | LearningSessionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningSessionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningSessionRecords
    **/
    _count?: true | LearningSessionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningSessionRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningSessionRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningSessionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningSessionRecordMaxAggregateInputType
  }

  export type GetLearningSessionRecordAggregateType<T extends LearningSessionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningSessionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningSessionRecord[P]>
      : GetScalarType<T[P], AggregateLearningSessionRecord[P]>
  }




  export type LearningSessionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionRecordWhereInput
    orderBy?: LearningSessionRecordOrderByWithAggregationInput | LearningSessionRecordOrderByWithAggregationInput[]
    by: LearningSessionRecordScalarFieldEnum[] | LearningSessionRecordScalarFieldEnum
    having?: LearningSessionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningSessionRecordCountAggregateInputType | true
    _avg?: LearningSessionRecordAvgAggregateInputType
    _sum?: LearningSessionRecordSumAggregateInputType
    _min?: LearningSessionRecordMinAggregateInputType
    _max?: LearningSessionRecordMaxAggregateInputType
  }

  export type LearningSessionRecordGroupByOutputType = {
    id: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt: Date
    sessionId: string
    vocabularyId: string
    _count: LearningSessionRecordCountAggregateOutputType | null
    _avg: LearningSessionRecordAvgAggregateOutputType | null
    _sum: LearningSessionRecordSumAggregateOutputType | null
    _min: LearningSessionRecordMinAggregateOutputType | null
    _max: LearningSessionRecordMaxAggregateOutputType | null
  }

  type GetLearningSessionRecordGroupByPayload<T extends LearningSessionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningSessionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningSessionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningSessionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], LearningSessionRecordGroupByOutputType[P]>
        }
      >
    >


  export type LearningSessionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isCorrect?: boolean
    responseTime?: boolean
    difficulty?: boolean
    createdAt?: boolean
    sessionId?: boolean
    vocabularyId?: boolean
    session?: boolean | LearningSessionDefaultArgs<ExtArgs>
    vocabulary?: boolean | VocabularyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningSessionRecord"]>

  export type LearningSessionRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isCorrect?: boolean
    responseTime?: boolean
    difficulty?: boolean
    createdAt?: boolean
    sessionId?: boolean
    vocabularyId?: boolean
    session?: boolean | LearningSessionDefaultArgs<ExtArgs>
    vocabulary?: boolean | VocabularyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningSessionRecord"]>

  export type LearningSessionRecordSelectScalar = {
    id?: boolean
    isCorrect?: boolean
    responseTime?: boolean
    difficulty?: boolean
    createdAt?: boolean
    sessionId?: boolean
    vocabularyId?: boolean
  }

  export type LearningSessionRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | LearningSessionDefaultArgs<ExtArgs>
    vocabulary?: boolean | VocabularyDefaultArgs<ExtArgs>
  }
  export type LearningSessionRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | LearningSessionDefaultArgs<ExtArgs>
    vocabulary?: boolean | VocabularyDefaultArgs<ExtArgs>
  }

  export type $LearningSessionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningSessionRecord"
    objects: {
      session: Prisma.$LearningSessionPayload<ExtArgs>
      vocabulary: Prisma.$VocabularyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isCorrect: boolean
      responseTime: number
      difficulty: number
      createdAt: Date
      sessionId: string
      vocabularyId: string
    }, ExtArgs["result"]["learningSessionRecord"]>
    composites: {}
  }

  type LearningSessionRecordGetPayload<S extends boolean | null | undefined | LearningSessionRecordDefaultArgs> = $Result.GetResult<Prisma.$LearningSessionRecordPayload, S>

  type LearningSessionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearningSessionRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearningSessionRecordCountAggregateInputType | true
    }

  export interface LearningSessionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningSessionRecord'], meta: { name: 'LearningSessionRecord' } }
    /**
     * Find zero or one LearningSessionRecord that matches the filter.
     * @param {LearningSessionRecordFindUniqueArgs} args - Arguments to find a LearningSessionRecord
     * @example
     * // Get one LearningSessionRecord
     * const learningSessionRecord = await prisma.learningSessionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningSessionRecordFindUniqueArgs>(args: SelectSubset<T, LearningSessionRecordFindUniqueArgs<ExtArgs>>): Prisma__LearningSessionRecordClient<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearningSessionRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearningSessionRecordFindUniqueOrThrowArgs} args - Arguments to find a LearningSessionRecord
     * @example
     * // Get one LearningSessionRecord
     * const learningSessionRecord = await prisma.learningSessionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningSessionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningSessionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningSessionRecordClient<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearningSessionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionRecordFindFirstArgs} args - Arguments to find a LearningSessionRecord
     * @example
     * // Get one LearningSessionRecord
     * const learningSessionRecord = await prisma.learningSessionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningSessionRecordFindFirstArgs>(args?: SelectSubset<T, LearningSessionRecordFindFirstArgs<ExtArgs>>): Prisma__LearningSessionRecordClient<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearningSessionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionRecordFindFirstOrThrowArgs} args - Arguments to find a LearningSessionRecord
     * @example
     * // Get one LearningSessionRecord
     * const learningSessionRecord = await prisma.learningSessionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningSessionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningSessionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningSessionRecordClient<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearningSessionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningSessionRecords
     * const learningSessionRecords = await prisma.learningSessionRecord.findMany()
     * 
     * // Get first 10 LearningSessionRecords
     * const learningSessionRecords = await prisma.learningSessionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningSessionRecordWithIdOnly = await prisma.learningSessionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningSessionRecordFindManyArgs>(args?: SelectSubset<T, LearningSessionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearningSessionRecord.
     * @param {LearningSessionRecordCreateArgs} args - Arguments to create a LearningSessionRecord.
     * @example
     * // Create one LearningSessionRecord
     * const LearningSessionRecord = await prisma.learningSessionRecord.create({
     *   data: {
     *     // ... data to create a LearningSessionRecord
     *   }
     * })
     * 
     */
    create<T extends LearningSessionRecordCreateArgs>(args: SelectSubset<T, LearningSessionRecordCreateArgs<ExtArgs>>): Prisma__LearningSessionRecordClient<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearningSessionRecords.
     * @param {LearningSessionRecordCreateManyArgs} args - Arguments to create many LearningSessionRecords.
     * @example
     * // Create many LearningSessionRecords
     * const learningSessionRecord = await prisma.learningSessionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningSessionRecordCreateManyArgs>(args?: SelectSubset<T, LearningSessionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningSessionRecords and returns the data saved in the database.
     * @param {LearningSessionRecordCreateManyAndReturnArgs} args - Arguments to create many LearningSessionRecords.
     * @example
     * // Create many LearningSessionRecords
     * const learningSessionRecord = await prisma.learningSessionRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningSessionRecords and only return the `id`
     * const learningSessionRecordWithIdOnly = await prisma.learningSessionRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningSessionRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningSessionRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearningSessionRecord.
     * @param {LearningSessionRecordDeleteArgs} args - Arguments to delete one LearningSessionRecord.
     * @example
     * // Delete one LearningSessionRecord
     * const LearningSessionRecord = await prisma.learningSessionRecord.delete({
     *   where: {
     *     // ... filter to delete one LearningSessionRecord
     *   }
     * })
     * 
     */
    delete<T extends LearningSessionRecordDeleteArgs>(args: SelectSubset<T, LearningSessionRecordDeleteArgs<ExtArgs>>): Prisma__LearningSessionRecordClient<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearningSessionRecord.
     * @param {LearningSessionRecordUpdateArgs} args - Arguments to update one LearningSessionRecord.
     * @example
     * // Update one LearningSessionRecord
     * const learningSessionRecord = await prisma.learningSessionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningSessionRecordUpdateArgs>(args: SelectSubset<T, LearningSessionRecordUpdateArgs<ExtArgs>>): Prisma__LearningSessionRecordClient<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearningSessionRecords.
     * @param {LearningSessionRecordDeleteManyArgs} args - Arguments to filter LearningSessionRecords to delete.
     * @example
     * // Delete a few LearningSessionRecords
     * const { count } = await prisma.learningSessionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningSessionRecordDeleteManyArgs>(args?: SelectSubset<T, LearningSessionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningSessionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningSessionRecords
     * const learningSessionRecord = await prisma.learningSessionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningSessionRecordUpdateManyArgs>(args: SelectSubset<T, LearningSessionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningSessionRecord.
     * @param {LearningSessionRecordUpsertArgs} args - Arguments to update or create a LearningSessionRecord.
     * @example
     * // Update or create a LearningSessionRecord
     * const learningSessionRecord = await prisma.learningSessionRecord.upsert({
     *   create: {
     *     // ... data to create a LearningSessionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningSessionRecord we want to update
     *   }
     * })
     */
    upsert<T extends LearningSessionRecordUpsertArgs>(args: SelectSubset<T, LearningSessionRecordUpsertArgs<ExtArgs>>): Prisma__LearningSessionRecordClient<$Result.GetResult<Prisma.$LearningSessionRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearningSessionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionRecordCountArgs} args - Arguments to filter LearningSessionRecords to count.
     * @example
     * // Count the number of LearningSessionRecords
     * const count = await prisma.learningSessionRecord.count({
     *   where: {
     *     // ... the filter for the LearningSessionRecords we want to count
     *   }
     * })
    **/
    count<T extends LearningSessionRecordCountArgs>(
      args?: Subset<T, LearningSessionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningSessionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningSessionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningSessionRecordAggregateArgs>(args: Subset<T, LearningSessionRecordAggregateArgs>): Prisma.PrismaPromise<GetLearningSessionRecordAggregateType<T>>

    /**
     * Group by LearningSessionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningSessionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningSessionRecordGroupByArgs['orderBy'] }
        : { orderBy?: LearningSessionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningSessionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningSessionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningSessionRecord model
   */
  readonly fields: LearningSessionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningSessionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningSessionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends LearningSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningSessionDefaultArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vocabulary<T extends VocabularyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VocabularyDefaultArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningSessionRecord model
   */ 
  interface LearningSessionRecordFieldRefs {
    readonly id: FieldRef<"LearningSessionRecord", 'String'>
    readonly isCorrect: FieldRef<"LearningSessionRecord", 'Boolean'>
    readonly responseTime: FieldRef<"LearningSessionRecord", 'Int'>
    readonly difficulty: FieldRef<"LearningSessionRecord", 'Int'>
    readonly createdAt: FieldRef<"LearningSessionRecord", 'DateTime'>
    readonly sessionId: FieldRef<"LearningSessionRecord", 'String'>
    readonly vocabularyId: FieldRef<"LearningSessionRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LearningSessionRecord findUnique
   */
  export type LearningSessionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    /**
     * Filter, which LearningSessionRecord to fetch.
     */
    where: LearningSessionRecordWhereUniqueInput
  }

  /**
   * LearningSessionRecord findUniqueOrThrow
   */
  export type LearningSessionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    /**
     * Filter, which LearningSessionRecord to fetch.
     */
    where: LearningSessionRecordWhereUniqueInput
  }

  /**
   * LearningSessionRecord findFirst
   */
  export type LearningSessionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    /**
     * Filter, which LearningSessionRecord to fetch.
     */
    where?: LearningSessionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessionRecords to fetch.
     */
    orderBy?: LearningSessionRecordOrderByWithRelationInput | LearningSessionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningSessionRecords.
     */
    cursor?: LearningSessionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningSessionRecords.
     */
    distinct?: LearningSessionRecordScalarFieldEnum | LearningSessionRecordScalarFieldEnum[]
  }

  /**
   * LearningSessionRecord findFirstOrThrow
   */
  export type LearningSessionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    /**
     * Filter, which LearningSessionRecord to fetch.
     */
    where?: LearningSessionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessionRecords to fetch.
     */
    orderBy?: LearningSessionRecordOrderByWithRelationInput | LearningSessionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningSessionRecords.
     */
    cursor?: LearningSessionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningSessionRecords.
     */
    distinct?: LearningSessionRecordScalarFieldEnum | LearningSessionRecordScalarFieldEnum[]
  }

  /**
   * LearningSessionRecord findMany
   */
  export type LearningSessionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    /**
     * Filter, which LearningSessionRecords to fetch.
     */
    where?: LearningSessionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessionRecords to fetch.
     */
    orderBy?: LearningSessionRecordOrderByWithRelationInput | LearningSessionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningSessionRecords.
     */
    cursor?: LearningSessionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessionRecords.
     */
    skip?: number
    distinct?: LearningSessionRecordScalarFieldEnum | LearningSessionRecordScalarFieldEnum[]
  }

  /**
   * LearningSessionRecord create
   */
  export type LearningSessionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningSessionRecord.
     */
    data: XOR<LearningSessionRecordCreateInput, LearningSessionRecordUncheckedCreateInput>
  }

  /**
   * LearningSessionRecord createMany
   */
  export type LearningSessionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningSessionRecords.
     */
    data: LearningSessionRecordCreateManyInput | LearningSessionRecordCreateManyInput[]
  }

  /**
   * LearningSessionRecord createManyAndReturn
   */
  export type LearningSessionRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearningSessionRecords.
     */
    data: LearningSessionRecordCreateManyInput | LearningSessionRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningSessionRecord update
   */
  export type LearningSessionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningSessionRecord.
     */
    data: XOR<LearningSessionRecordUpdateInput, LearningSessionRecordUncheckedUpdateInput>
    /**
     * Choose, which LearningSessionRecord to update.
     */
    where: LearningSessionRecordWhereUniqueInput
  }

  /**
   * LearningSessionRecord updateMany
   */
  export type LearningSessionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningSessionRecords.
     */
    data: XOR<LearningSessionRecordUpdateManyMutationInput, LearningSessionRecordUncheckedUpdateManyInput>
    /**
     * Filter which LearningSessionRecords to update
     */
    where?: LearningSessionRecordWhereInput
  }

  /**
   * LearningSessionRecord upsert
   */
  export type LearningSessionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningSessionRecord to update in case it exists.
     */
    where: LearningSessionRecordWhereUniqueInput
    /**
     * In case the LearningSessionRecord found by the `where` argument doesn't exist, create a new LearningSessionRecord with this data.
     */
    create: XOR<LearningSessionRecordCreateInput, LearningSessionRecordUncheckedCreateInput>
    /**
     * In case the LearningSessionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningSessionRecordUpdateInput, LearningSessionRecordUncheckedUpdateInput>
  }

  /**
   * LearningSessionRecord delete
   */
  export type LearningSessionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
    /**
     * Filter which LearningSessionRecord to delete.
     */
    where: LearningSessionRecordWhereUniqueInput
  }

  /**
   * LearningSessionRecord deleteMany
   */
  export type LearningSessionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningSessionRecords to delete
     */
    where?: LearningSessionRecordWhereInput
  }

  /**
   * LearningSessionRecord without action
   */
  export type LearningSessionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSessionRecord
     */
    select?: LearningSessionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionRecordInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    achievementValue: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    achievementValue: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    achievementType: string | null
    achievementValue: number | null
    unlockedAt: Date | null
    userId: string | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    achievementType: string | null
    achievementValue: number | null
    unlockedAt: Date | null
    userId: string | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    achievementType: number
    achievementValue: number
    unlockedAt: number
    userId: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    achievementValue?: true
  }

  export type UserAchievementSumAggregateInputType = {
    achievementValue?: true
  }

  export type UserAchievementMinAggregateInputType = {
    id?: true
    achievementType?: true
    achievementValue?: true
    unlockedAt?: true
    userId?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    achievementType?: true
    achievementValue?: true
    unlockedAt?: true
    userId?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    achievementType?: true
    achievementValue?: true
    unlockedAt?: true
    userId?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    achievementType: string
    achievementValue: number
    unlockedAt: Date
    userId: string
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    achievementType?: boolean
    achievementValue?: boolean
    unlockedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    achievementType?: boolean
    achievementValue?: boolean
    unlockedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    achievementType?: boolean
    achievementValue?: boolean
    unlockedAt?: boolean
    userId?: boolean
  }

  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      achievementType: string
      achievementValue: number
      unlockedAt: Date
      userId: string
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */ 
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly achievementType: FieldRef<"UserAchievement", 'String'>
    readonly achievementValue: FieldRef<"UserAchievement", 'Int'>
    readonly unlockedAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model ReadingArticle
   */

  export type AggregateReadingArticle = {
    _count: ReadingArticleCountAggregateOutputType | null
    _avg: ReadingArticleAvgAggregateOutputType | null
    _sum: ReadingArticleSumAggregateOutputType | null
    _min: ReadingArticleMinAggregateOutputType | null
    _max: ReadingArticleMaxAggregateOutputType | null
  }

  export type ReadingArticleAvgAggregateOutputType = {
    difficulty: number | null
    wordCount: number | null
    readingTime: number | null
  }

  export type ReadingArticleSumAggregateOutputType = {
    difficulty: number | null
    wordCount: number | null
    readingTime: number | null
  }

  export type ReadingArticleMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    summary: string | null
    difficulty: number | null
    wordCount: number | null
    readingTime: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReadingArticleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    summary: string | null
    difficulty: number | null
    wordCount: number | null
    readingTime: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReadingArticleCountAggregateOutputType = {
    id: number
    title: number
    content: number
    summary: number
    difficulty: number
    wordCount: number
    readingTime: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReadingArticleAvgAggregateInputType = {
    difficulty?: true
    wordCount?: true
    readingTime?: true
  }

  export type ReadingArticleSumAggregateInputType = {
    difficulty?: true
    wordCount?: true
    readingTime?: true
  }

  export type ReadingArticleMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    summary?: true
    difficulty?: true
    wordCount?: true
    readingTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReadingArticleMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    summary?: true
    difficulty?: true
    wordCount?: true
    readingTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReadingArticleCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    summary?: true
    difficulty?: true
    wordCount?: true
    readingTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReadingArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReadingArticle to aggregate.
     */
    where?: ReadingArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingArticles to fetch.
     */
    orderBy?: ReadingArticleOrderByWithRelationInput | ReadingArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReadingArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReadingArticles
    **/
    _count?: true | ReadingArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReadingArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReadingArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReadingArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReadingArticleMaxAggregateInputType
  }

  export type GetReadingArticleAggregateType<T extends ReadingArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateReadingArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReadingArticle[P]>
      : GetScalarType<T[P], AggregateReadingArticle[P]>
  }




  export type ReadingArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingArticleWhereInput
    orderBy?: ReadingArticleOrderByWithAggregationInput | ReadingArticleOrderByWithAggregationInput[]
    by: ReadingArticleScalarFieldEnum[] | ReadingArticleScalarFieldEnum
    having?: ReadingArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReadingArticleCountAggregateInputType | true
    _avg?: ReadingArticleAvgAggregateInputType
    _sum?: ReadingArticleSumAggregateInputType
    _min?: ReadingArticleMinAggregateInputType
    _max?: ReadingArticleMaxAggregateInputType
  }

  export type ReadingArticleGroupByOutputType = {
    id: string
    title: string
    content: string
    summary: string | null
    difficulty: number
    wordCount: number
    readingTime: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ReadingArticleCountAggregateOutputType | null
    _avg: ReadingArticleAvgAggregateOutputType | null
    _sum: ReadingArticleSumAggregateOutputType | null
    _min: ReadingArticleMinAggregateOutputType | null
    _max: ReadingArticleMaxAggregateOutputType | null
  }

  type GetReadingArticleGroupByPayload<T extends ReadingArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReadingArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReadingArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReadingArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ReadingArticleGroupByOutputType[P]>
        }
      >
    >


  export type ReadingArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    difficulty?: boolean
    wordCount?: boolean
    readingTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userReadingRecords?: boolean | ReadingArticle$userReadingRecordsArgs<ExtArgs>
    _count?: boolean | ReadingArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readingArticle"]>

  export type ReadingArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    difficulty?: boolean
    wordCount?: boolean
    readingTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["readingArticle"]>

  export type ReadingArticleSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    difficulty?: boolean
    wordCount?: boolean
    readingTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReadingArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userReadingRecords?: boolean | ReadingArticle$userReadingRecordsArgs<ExtArgs>
    _count?: boolean | ReadingArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReadingArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReadingArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReadingArticle"
    objects: {
      userReadingRecords: Prisma.$UserReadingRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      summary: string | null
      difficulty: number
      wordCount: number
      readingTime: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["readingArticle"]>
    composites: {}
  }

  type ReadingArticleGetPayload<S extends boolean | null | undefined | ReadingArticleDefaultArgs> = $Result.GetResult<Prisma.$ReadingArticlePayload, S>

  type ReadingArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReadingArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReadingArticleCountAggregateInputType | true
    }

  export interface ReadingArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReadingArticle'], meta: { name: 'ReadingArticle' } }
    /**
     * Find zero or one ReadingArticle that matches the filter.
     * @param {ReadingArticleFindUniqueArgs} args - Arguments to find a ReadingArticle
     * @example
     * // Get one ReadingArticle
     * const readingArticle = await prisma.readingArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReadingArticleFindUniqueArgs>(args: SelectSubset<T, ReadingArticleFindUniqueArgs<ExtArgs>>): Prisma__ReadingArticleClient<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReadingArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReadingArticleFindUniqueOrThrowArgs} args - Arguments to find a ReadingArticle
     * @example
     * // Get one ReadingArticle
     * const readingArticle = await prisma.readingArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReadingArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, ReadingArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReadingArticleClient<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReadingArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingArticleFindFirstArgs} args - Arguments to find a ReadingArticle
     * @example
     * // Get one ReadingArticle
     * const readingArticle = await prisma.readingArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReadingArticleFindFirstArgs>(args?: SelectSubset<T, ReadingArticleFindFirstArgs<ExtArgs>>): Prisma__ReadingArticleClient<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReadingArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingArticleFindFirstOrThrowArgs} args - Arguments to find a ReadingArticle
     * @example
     * // Get one ReadingArticle
     * const readingArticle = await prisma.readingArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReadingArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, ReadingArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReadingArticleClient<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReadingArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReadingArticles
     * const readingArticles = await prisma.readingArticle.findMany()
     * 
     * // Get first 10 ReadingArticles
     * const readingArticles = await prisma.readingArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const readingArticleWithIdOnly = await prisma.readingArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReadingArticleFindManyArgs>(args?: SelectSubset<T, ReadingArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReadingArticle.
     * @param {ReadingArticleCreateArgs} args - Arguments to create a ReadingArticle.
     * @example
     * // Create one ReadingArticle
     * const ReadingArticle = await prisma.readingArticle.create({
     *   data: {
     *     // ... data to create a ReadingArticle
     *   }
     * })
     * 
     */
    create<T extends ReadingArticleCreateArgs>(args: SelectSubset<T, ReadingArticleCreateArgs<ExtArgs>>): Prisma__ReadingArticleClient<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReadingArticles.
     * @param {ReadingArticleCreateManyArgs} args - Arguments to create many ReadingArticles.
     * @example
     * // Create many ReadingArticles
     * const readingArticle = await prisma.readingArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReadingArticleCreateManyArgs>(args?: SelectSubset<T, ReadingArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReadingArticles and returns the data saved in the database.
     * @param {ReadingArticleCreateManyAndReturnArgs} args - Arguments to create many ReadingArticles.
     * @example
     * // Create many ReadingArticles
     * const readingArticle = await prisma.readingArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReadingArticles and only return the `id`
     * const readingArticleWithIdOnly = await prisma.readingArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReadingArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, ReadingArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReadingArticle.
     * @param {ReadingArticleDeleteArgs} args - Arguments to delete one ReadingArticle.
     * @example
     * // Delete one ReadingArticle
     * const ReadingArticle = await prisma.readingArticle.delete({
     *   where: {
     *     // ... filter to delete one ReadingArticle
     *   }
     * })
     * 
     */
    delete<T extends ReadingArticleDeleteArgs>(args: SelectSubset<T, ReadingArticleDeleteArgs<ExtArgs>>): Prisma__ReadingArticleClient<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReadingArticle.
     * @param {ReadingArticleUpdateArgs} args - Arguments to update one ReadingArticle.
     * @example
     * // Update one ReadingArticle
     * const readingArticle = await prisma.readingArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReadingArticleUpdateArgs>(args: SelectSubset<T, ReadingArticleUpdateArgs<ExtArgs>>): Prisma__ReadingArticleClient<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReadingArticles.
     * @param {ReadingArticleDeleteManyArgs} args - Arguments to filter ReadingArticles to delete.
     * @example
     * // Delete a few ReadingArticles
     * const { count } = await prisma.readingArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReadingArticleDeleteManyArgs>(args?: SelectSubset<T, ReadingArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReadingArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReadingArticles
     * const readingArticle = await prisma.readingArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReadingArticleUpdateManyArgs>(args: SelectSubset<T, ReadingArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReadingArticle.
     * @param {ReadingArticleUpsertArgs} args - Arguments to update or create a ReadingArticle.
     * @example
     * // Update or create a ReadingArticle
     * const readingArticle = await prisma.readingArticle.upsert({
     *   create: {
     *     // ... data to create a ReadingArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReadingArticle we want to update
     *   }
     * })
     */
    upsert<T extends ReadingArticleUpsertArgs>(args: SelectSubset<T, ReadingArticleUpsertArgs<ExtArgs>>): Prisma__ReadingArticleClient<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReadingArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingArticleCountArgs} args - Arguments to filter ReadingArticles to count.
     * @example
     * // Count the number of ReadingArticles
     * const count = await prisma.readingArticle.count({
     *   where: {
     *     // ... the filter for the ReadingArticles we want to count
     *   }
     * })
    **/
    count<T extends ReadingArticleCountArgs>(
      args?: Subset<T, ReadingArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReadingArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReadingArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReadingArticleAggregateArgs>(args: Subset<T, ReadingArticleAggregateArgs>): Prisma.PrismaPromise<GetReadingArticleAggregateType<T>>

    /**
     * Group by ReadingArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReadingArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReadingArticleGroupByArgs['orderBy'] }
        : { orderBy?: ReadingArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReadingArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReadingArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReadingArticle model
   */
  readonly fields: ReadingArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReadingArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReadingArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userReadingRecords<T extends ReadingArticle$userReadingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, ReadingArticle$userReadingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReadingArticle model
   */ 
  interface ReadingArticleFieldRefs {
    readonly id: FieldRef<"ReadingArticle", 'String'>
    readonly title: FieldRef<"ReadingArticle", 'String'>
    readonly content: FieldRef<"ReadingArticle", 'String'>
    readonly summary: FieldRef<"ReadingArticle", 'String'>
    readonly difficulty: FieldRef<"ReadingArticle", 'Int'>
    readonly wordCount: FieldRef<"ReadingArticle", 'Int'>
    readonly readingTime: FieldRef<"ReadingArticle", 'Int'>
    readonly isActive: FieldRef<"ReadingArticle", 'Boolean'>
    readonly createdAt: FieldRef<"ReadingArticle", 'DateTime'>
    readonly updatedAt: FieldRef<"ReadingArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReadingArticle findUnique
   */
  export type ReadingArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
    /**
     * Filter, which ReadingArticle to fetch.
     */
    where: ReadingArticleWhereUniqueInput
  }

  /**
   * ReadingArticle findUniqueOrThrow
   */
  export type ReadingArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
    /**
     * Filter, which ReadingArticle to fetch.
     */
    where: ReadingArticleWhereUniqueInput
  }

  /**
   * ReadingArticle findFirst
   */
  export type ReadingArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
    /**
     * Filter, which ReadingArticle to fetch.
     */
    where?: ReadingArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingArticles to fetch.
     */
    orderBy?: ReadingArticleOrderByWithRelationInput | ReadingArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReadingArticles.
     */
    cursor?: ReadingArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReadingArticles.
     */
    distinct?: ReadingArticleScalarFieldEnum | ReadingArticleScalarFieldEnum[]
  }

  /**
   * ReadingArticle findFirstOrThrow
   */
  export type ReadingArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
    /**
     * Filter, which ReadingArticle to fetch.
     */
    where?: ReadingArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingArticles to fetch.
     */
    orderBy?: ReadingArticleOrderByWithRelationInput | ReadingArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReadingArticles.
     */
    cursor?: ReadingArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReadingArticles.
     */
    distinct?: ReadingArticleScalarFieldEnum | ReadingArticleScalarFieldEnum[]
  }

  /**
   * ReadingArticle findMany
   */
  export type ReadingArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
    /**
     * Filter, which ReadingArticles to fetch.
     */
    where?: ReadingArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingArticles to fetch.
     */
    orderBy?: ReadingArticleOrderByWithRelationInput | ReadingArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReadingArticles.
     */
    cursor?: ReadingArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingArticles.
     */
    skip?: number
    distinct?: ReadingArticleScalarFieldEnum | ReadingArticleScalarFieldEnum[]
  }

  /**
   * ReadingArticle create
   */
  export type ReadingArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a ReadingArticle.
     */
    data: XOR<ReadingArticleCreateInput, ReadingArticleUncheckedCreateInput>
  }

  /**
   * ReadingArticle createMany
   */
  export type ReadingArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReadingArticles.
     */
    data: ReadingArticleCreateManyInput | ReadingArticleCreateManyInput[]
  }

  /**
   * ReadingArticle createManyAndReturn
   */
  export type ReadingArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReadingArticles.
     */
    data: ReadingArticleCreateManyInput | ReadingArticleCreateManyInput[]
  }

  /**
   * ReadingArticle update
   */
  export type ReadingArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a ReadingArticle.
     */
    data: XOR<ReadingArticleUpdateInput, ReadingArticleUncheckedUpdateInput>
    /**
     * Choose, which ReadingArticle to update.
     */
    where: ReadingArticleWhereUniqueInput
  }

  /**
   * ReadingArticle updateMany
   */
  export type ReadingArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReadingArticles.
     */
    data: XOR<ReadingArticleUpdateManyMutationInput, ReadingArticleUncheckedUpdateManyInput>
    /**
     * Filter which ReadingArticles to update
     */
    where?: ReadingArticleWhereInput
  }

  /**
   * ReadingArticle upsert
   */
  export type ReadingArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the ReadingArticle to update in case it exists.
     */
    where: ReadingArticleWhereUniqueInput
    /**
     * In case the ReadingArticle found by the `where` argument doesn't exist, create a new ReadingArticle with this data.
     */
    create: XOR<ReadingArticleCreateInput, ReadingArticleUncheckedCreateInput>
    /**
     * In case the ReadingArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReadingArticleUpdateInput, ReadingArticleUncheckedUpdateInput>
  }

  /**
   * ReadingArticle delete
   */
  export type ReadingArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
    /**
     * Filter which ReadingArticle to delete.
     */
    where: ReadingArticleWhereUniqueInput
  }

  /**
   * ReadingArticle deleteMany
   */
  export type ReadingArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReadingArticles to delete
     */
    where?: ReadingArticleWhereInput
  }

  /**
   * ReadingArticle.userReadingRecords
   */
  export type ReadingArticle$userReadingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    where?: UserReadingRecordWhereInput
    orderBy?: UserReadingRecordOrderByWithRelationInput | UserReadingRecordOrderByWithRelationInput[]
    cursor?: UserReadingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserReadingRecordScalarFieldEnum | UserReadingRecordScalarFieldEnum[]
  }

  /**
   * ReadingArticle without action
   */
  export type ReadingArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingArticle
     */
    select?: ReadingArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingArticleInclude<ExtArgs> | null
  }


  /**
   * Model UserReadingRecord
   */

  export type AggregateUserReadingRecord = {
    _count: UserReadingRecordCountAggregateOutputType | null
    _avg: UserReadingRecordAvgAggregateOutputType | null
    _sum: UserReadingRecordSumAggregateOutputType | null
    _min: UserReadingRecordMinAggregateOutputType | null
    _max: UserReadingRecordMaxAggregateOutputType | null
  }

  export type UserReadingRecordAvgAggregateOutputType = {
    readingTime: number | null
    comprehension: number | null
    wordsLearned: number | null
  }

  export type UserReadingRecordSumAggregateOutputType = {
    readingTime: number | null
    comprehension: number | null
    wordsLearned: number | null
  }

  export type UserReadingRecordMinAggregateOutputType = {
    id: string | null
    readingTime: number | null
    comprehension: number | null
    wordsLearned: number | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    articleId: string | null
  }

  export type UserReadingRecordMaxAggregateOutputType = {
    id: string | null
    readingTime: number | null
    comprehension: number | null
    wordsLearned: number | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    articleId: string | null
  }

  export type UserReadingRecordCountAggregateOutputType = {
    id: number
    readingTime: number
    comprehension: number
    wordsLearned: number
    isCompleted: number
    createdAt: number
    updatedAt: number
    userId: number
    articleId: number
    _all: number
  }


  export type UserReadingRecordAvgAggregateInputType = {
    readingTime?: true
    comprehension?: true
    wordsLearned?: true
  }

  export type UserReadingRecordSumAggregateInputType = {
    readingTime?: true
    comprehension?: true
    wordsLearned?: true
  }

  export type UserReadingRecordMinAggregateInputType = {
    id?: true
    readingTime?: true
    comprehension?: true
    wordsLearned?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    articleId?: true
  }

  export type UserReadingRecordMaxAggregateInputType = {
    id?: true
    readingTime?: true
    comprehension?: true
    wordsLearned?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    articleId?: true
  }

  export type UserReadingRecordCountAggregateInputType = {
    id?: true
    readingTime?: true
    comprehension?: true
    wordsLearned?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    articleId?: true
    _all?: true
  }

  export type UserReadingRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserReadingRecord to aggregate.
     */
    where?: UserReadingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReadingRecords to fetch.
     */
    orderBy?: UserReadingRecordOrderByWithRelationInput | UserReadingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserReadingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReadingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReadingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserReadingRecords
    **/
    _count?: true | UserReadingRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserReadingRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserReadingRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserReadingRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserReadingRecordMaxAggregateInputType
  }

  export type GetUserReadingRecordAggregateType<T extends UserReadingRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateUserReadingRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserReadingRecord[P]>
      : GetScalarType<T[P], AggregateUserReadingRecord[P]>
  }




  export type UserReadingRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserReadingRecordWhereInput
    orderBy?: UserReadingRecordOrderByWithAggregationInput | UserReadingRecordOrderByWithAggregationInput[]
    by: UserReadingRecordScalarFieldEnum[] | UserReadingRecordScalarFieldEnum
    having?: UserReadingRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserReadingRecordCountAggregateInputType | true
    _avg?: UserReadingRecordAvgAggregateInputType
    _sum?: UserReadingRecordSumAggregateInputType
    _min?: UserReadingRecordMinAggregateInputType
    _max?: UserReadingRecordMaxAggregateInputType
  }

  export type UserReadingRecordGroupByOutputType = {
    id: string
    readingTime: number
    comprehension: number
    wordsLearned: number
    isCompleted: boolean
    createdAt: Date
    updatedAt: Date
    userId: string
    articleId: string
    _count: UserReadingRecordCountAggregateOutputType | null
    _avg: UserReadingRecordAvgAggregateOutputType | null
    _sum: UserReadingRecordSumAggregateOutputType | null
    _min: UserReadingRecordMinAggregateOutputType | null
    _max: UserReadingRecordMaxAggregateOutputType | null
  }

  type GetUserReadingRecordGroupByPayload<T extends UserReadingRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserReadingRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserReadingRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserReadingRecordGroupByOutputType[P]>
            : GetScalarType<T[P], UserReadingRecordGroupByOutputType[P]>
        }
      >
    >


  export type UserReadingRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    readingTime?: boolean
    comprehension?: boolean
    wordsLearned?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    articleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | ReadingArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userReadingRecord"]>

  export type UserReadingRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    readingTime?: boolean
    comprehension?: boolean
    wordsLearned?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    articleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | ReadingArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userReadingRecord"]>

  export type UserReadingRecordSelectScalar = {
    id?: boolean
    readingTime?: boolean
    comprehension?: boolean
    wordsLearned?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    articleId?: boolean
  }

  export type UserReadingRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | ReadingArticleDefaultArgs<ExtArgs>
  }
  export type UserReadingRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | ReadingArticleDefaultArgs<ExtArgs>
  }

  export type $UserReadingRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserReadingRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      article: Prisma.$ReadingArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      readingTime: number
      comprehension: number
      wordsLearned: number
      isCompleted: boolean
      createdAt: Date
      updatedAt: Date
      userId: string
      articleId: string
    }, ExtArgs["result"]["userReadingRecord"]>
    composites: {}
  }

  type UserReadingRecordGetPayload<S extends boolean | null | undefined | UserReadingRecordDefaultArgs> = $Result.GetResult<Prisma.$UserReadingRecordPayload, S>

  type UserReadingRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserReadingRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserReadingRecordCountAggregateInputType | true
    }

  export interface UserReadingRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserReadingRecord'], meta: { name: 'UserReadingRecord' } }
    /**
     * Find zero or one UserReadingRecord that matches the filter.
     * @param {UserReadingRecordFindUniqueArgs} args - Arguments to find a UserReadingRecord
     * @example
     * // Get one UserReadingRecord
     * const userReadingRecord = await prisma.userReadingRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserReadingRecordFindUniqueArgs>(args: SelectSubset<T, UserReadingRecordFindUniqueArgs<ExtArgs>>): Prisma__UserReadingRecordClient<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserReadingRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserReadingRecordFindUniqueOrThrowArgs} args - Arguments to find a UserReadingRecord
     * @example
     * // Get one UserReadingRecord
     * const userReadingRecord = await prisma.userReadingRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserReadingRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, UserReadingRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserReadingRecordClient<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserReadingRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReadingRecordFindFirstArgs} args - Arguments to find a UserReadingRecord
     * @example
     * // Get one UserReadingRecord
     * const userReadingRecord = await prisma.userReadingRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserReadingRecordFindFirstArgs>(args?: SelectSubset<T, UserReadingRecordFindFirstArgs<ExtArgs>>): Prisma__UserReadingRecordClient<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserReadingRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReadingRecordFindFirstOrThrowArgs} args - Arguments to find a UserReadingRecord
     * @example
     * // Get one UserReadingRecord
     * const userReadingRecord = await prisma.userReadingRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserReadingRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, UserReadingRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserReadingRecordClient<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserReadingRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReadingRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserReadingRecords
     * const userReadingRecords = await prisma.userReadingRecord.findMany()
     * 
     * // Get first 10 UserReadingRecords
     * const userReadingRecords = await prisma.userReadingRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userReadingRecordWithIdOnly = await prisma.userReadingRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserReadingRecordFindManyArgs>(args?: SelectSubset<T, UserReadingRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserReadingRecord.
     * @param {UserReadingRecordCreateArgs} args - Arguments to create a UserReadingRecord.
     * @example
     * // Create one UserReadingRecord
     * const UserReadingRecord = await prisma.userReadingRecord.create({
     *   data: {
     *     // ... data to create a UserReadingRecord
     *   }
     * })
     * 
     */
    create<T extends UserReadingRecordCreateArgs>(args: SelectSubset<T, UserReadingRecordCreateArgs<ExtArgs>>): Prisma__UserReadingRecordClient<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserReadingRecords.
     * @param {UserReadingRecordCreateManyArgs} args - Arguments to create many UserReadingRecords.
     * @example
     * // Create many UserReadingRecords
     * const userReadingRecord = await prisma.userReadingRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserReadingRecordCreateManyArgs>(args?: SelectSubset<T, UserReadingRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserReadingRecords and returns the data saved in the database.
     * @param {UserReadingRecordCreateManyAndReturnArgs} args - Arguments to create many UserReadingRecords.
     * @example
     * // Create many UserReadingRecords
     * const userReadingRecord = await prisma.userReadingRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserReadingRecords and only return the `id`
     * const userReadingRecordWithIdOnly = await prisma.userReadingRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserReadingRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, UserReadingRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserReadingRecord.
     * @param {UserReadingRecordDeleteArgs} args - Arguments to delete one UserReadingRecord.
     * @example
     * // Delete one UserReadingRecord
     * const UserReadingRecord = await prisma.userReadingRecord.delete({
     *   where: {
     *     // ... filter to delete one UserReadingRecord
     *   }
     * })
     * 
     */
    delete<T extends UserReadingRecordDeleteArgs>(args: SelectSubset<T, UserReadingRecordDeleteArgs<ExtArgs>>): Prisma__UserReadingRecordClient<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserReadingRecord.
     * @param {UserReadingRecordUpdateArgs} args - Arguments to update one UserReadingRecord.
     * @example
     * // Update one UserReadingRecord
     * const userReadingRecord = await prisma.userReadingRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserReadingRecordUpdateArgs>(args: SelectSubset<T, UserReadingRecordUpdateArgs<ExtArgs>>): Prisma__UserReadingRecordClient<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserReadingRecords.
     * @param {UserReadingRecordDeleteManyArgs} args - Arguments to filter UserReadingRecords to delete.
     * @example
     * // Delete a few UserReadingRecords
     * const { count } = await prisma.userReadingRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserReadingRecordDeleteManyArgs>(args?: SelectSubset<T, UserReadingRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserReadingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReadingRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserReadingRecords
     * const userReadingRecord = await prisma.userReadingRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserReadingRecordUpdateManyArgs>(args: SelectSubset<T, UserReadingRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserReadingRecord.
     * @param {UserReadingRecordUpsertArgs} args - Arguments to update or create a UserReadingRecord.
     * @example
     * // Update or create a UserReadingRecord
     * const userReadingRecord = await prisma.userReadingRecord.upsert({
     *   create: {
     *     // ... data to create a UserReadingRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserReadingRecord we want to update
     *   }
     * })
     */
    upsert<T extends UserReadingRecordUpsertArgs>(args: SelectSubset<T, UserReadingRecordUpsertArgs<ExtArgs>>): Prisma__UserReadingRecordClient<$Result.GetResult<Prisma.$UserReadingRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserReadingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReadingRecordCountArgs} args - Arguments to filter UserReadingRecords to count.
     * @example
     * // Count the number of UserReadingRecords
     * const count = await prisma.userReadingRecord.count({
     *   where: {
     *     // ... the filter for the UserReadingRecords we want to count
     *   }
     * })
    **/
    count<T extends UserReadingRecordCountArgs>(
      args?: Subset<T, UserReadingRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserReadingRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserReadingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReadingRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserReadingRecordAggregateArgs>(args: Subset<T, UserReadingRecordAggregateArgs>): Prisma.PrismaPromise<GetUserReadingRecordAggregateType<T>>

    /**
     * Group by UserReadingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReadingRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserReadingRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserReadingRecordGroupByArgs['orderBy'] }
        : { orderBy?: UserReadingRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserReadingRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserReadingRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserReadingRecord model
   */
  readonly fields: UserReadingRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserReadingRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserReadingRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    article<T extends ReadingArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReadingArticleDefaultArgs<ExtArgs>>): Prisma__ReadingArticleClient<$Result.GetResult<Prisma.$ReadingArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserReadingRecord model
   */ 
  interface UserReadingRecordFieldRefs {
    readonly id: FieldRef<"UserReadingRecord", 'String'>
    readonly readingTime: FieldRef<"UserReadingRecord", 'Int'>
    readonly comprehension: FieldRef<"UserReadingRecord", 'Float'>
    readonly wordsLearned: FieldRef<"UserReadingRecord", 'Int'>
    readonly isCompleted: FieldRef<"UserReadingRecord", 'Boolean'>
    readonly createdAt: FieldRef<"UserReadingRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"UserReadingRecord", 'DateTime'>
    readonly userId: FieldRef<"UserReadingRecord", 'String'>
    readonly articleId: FieldRef<"UserReadingRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserReadingRecord findUnique
   */
  export type UserReadingRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    /**
     * Filter, which UserReadingRecord to fetch.
     */
    where: UserReadingRecordWhereUniqueInput
  }

  /**
   * UserReadingRecord findUniqueOrThrow
   */
  export type UserReadingRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    /**
     * Filter, which UserReadingRecord to fetch.
     */
    where: UserReadingRecordWhereUniqueInput
  }

  /**
   * UserReadingRecord findFirst
   */
  export type UserReadingRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    /**
     * Filter, which UserReadingRecord to fetch.
     */
    where?: UserReadingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReadingRecords to fetch.
     */
    orderBy?: UserReadingRecordOrderByWithRelationInput | UserReadingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserReadingRecords.
     */
    cursor?: UserReadingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReadingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReadingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserReadingRecords.
     */
    distinct?: UserReadingRecordScalarFieldEnum | UserReadingRecordScalarFieldEnum[]
  }

  /**
   * UserReadingRecord findFirstOrThrow
   */
  export type UserReadingRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    /**
     * Filter, which UserReadingRecord to fetch.
     */
    where?: UserReadingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReadingRecords to fetch.
     */
    orderBy?: UserReadingRecordOrderByWithRelationInput | UserReadingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserReadingRecords.
     */
    cursor?: UserReadingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReadingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReadingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserReadingRecords.
     */
    distinct?: UserReadingRecordScalarFieldEnum | UserReadingRecordScalarFieldEnum[]
  }

  /**
   * UserReadingRecord findMany
   */
  export type UserReadingRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    /**
     * Filter, which UserReadingRecords to fetch.
     */
    where?: UserReadingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReadingRecords to fetch.
     */
    orderBy?: UserReadingRecordOrderByWithRelationInput | UserReadingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserReadingRecords.
     */
    cursor?: UserReadingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReadingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReadingRecords.
     */
    skip?: number
    distinct?: UserReadingRecordScalarFieldEnum | UserReadingRecordScalarFieldEnum[]
  }

  /**
   * UserReadingRecord create
   */
  export type UserReadingRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a UserReadingRecord.
     */
    data: XOR<UserReadingRecordCreateInput, UserReadingRecordUncheckedCreateInput>
  }

  /**
   * UserReadingRecord createMany
   */
  export type UserReadingRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserReadingRecords.
     */
    data: UserReadingRecordCreateManyInput | UserReadingRecordCreateManyInput[]
  }

  /**
   * UserReadingRecord createManyAndReturn
   */
  export type UserReadingRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserReadingRecords.
     */
    data: UserReadingRecordCreateManyInput | UserReadingRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserReadingRecord update
   */
  export type UserReadingRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a UserReadingRecord.
     */
    data: XOR<UserReadingRecordUpdateInput, UserReadingRecordUncheckedUpdateInput>
    /**
     * Choose, which UserReadingRecord to update.
     */
    where: UserReadingRecordWhereUniqueInput
  }

  /**
   * UserReadingRecord updateMany
   */
  export type UserReadingRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserReadingRecords.
     */
    data: XOR<UserReadingRecordUpdateManyMutationInput, UserReadingRecordUncheckedUpdateManyInput>
    /**
     * Filter which UserReadingRecords to update
     */
    where?: UserReadingRecordWhereInput
  }

  /**
   * UserReadingRecord upsert
   */
  export type UserReadingRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the UserReadingRecord to update in case it exists.
     */
    where: UserReadingRecordWhereUniqueInput
    /**
     * In case the UserReadingRecord found by the `where` argument doesn't exist, create a new UserReadingRecord with this data.
     */
    create: XOR<UserReadingRecordCreateInput, UserReadingRecordUncheckedCreateInput>
    /**
     * In case the UserReadingRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserReadingRecordUpdateInput, UserReadingRecordUncheckedUpdateInput>
  }

  /**
   * UserReadingRecord delete
   */
  export type UserReadingRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
    /**
     * Filter which UserReadingRecord to delete.
     */
    where: UserReadingRecordWhereUniqueInput
  }

  /**
   * UserReadingRecord deleteMany
   */
  export type UserReadingRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserReadingRecords to delete
     */
    where?: UserReadingRecordWhereInput
  }

  /**
   * UserReadingRecord without action
   */
  export type UserReadingRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReadingRecord
     */
    select?: UserReadingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReadingRecordInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt',
    preferences: 'preferences'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VocabularyCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VocabularyCategoryScalarFieldEnum = (typeof VocabularyCategoryScalarFieldEnum)[keyof typeof VocabularyCategoryScalarFieldEnum]


  export const VocabularyScalarFieldEnum: {
    id: 'id',
    word: 'word',
    pronunciation: 'pronunciation',
    definition: 'definition',
    example: 'example',
    difficulty: 'difficulty',
    frequency: 'frequency',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    categoryId: 'categoryId'
  };

  export type VocabularyScalarFieldEnum = (typeof VocabularyScalarFieldEnum)[keyof typeof VocabularyScalarFieldEnum]


  export const UserVocabularyScalarFieldEnum: {
    id: 'id',
    masteryLevel: 'masteryLevel',
    reviewCount: 'reviewCount',
    correctCount: 'correctCount',
    consecutiveCorrect: 'consecutiveCorrect',
    nextReviewAt: 'nextReviewAt',
    lastReviewAt: 'lastReviewAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    vocabularyId: 'vocabularyId'
  };

  export type UserVocabularyScalarFieldEnum = (typeof UserVocabularyScalarFieldEnum)[keyof typeof UserVocabularyScalarFieldEnum]


  export const LearningSessionScalarFieldEnum: {
    id: 'id',
    sessionType: 'sessionType',
    startTime: 'startTime',
    endTime: 'endTime',
    totalWords: 'totalWords',
    correctAnswers: 'correctAnswers',
    timeSpent: 'timeSpent',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type LearningSessionScalarFieldEnum = (typeof LearningSessionScalarFieldEnum)[keyof typeof LearningSessionScalarFieldEnum]


  export const LearningSessionRecordScalarFieldEnum: {
    id: 'id',
    isCorrect: 'isCorrect',
    responseTime: 'responseTime',
    difficulty: 'difficulty',
    createdAt: 'createdAt',
    sessionId: 'sessionId',
    vocabularyId: 'vocabularyId'
  };

  export type LearningSessionRecordScalarFieldEnum = (typeof LearningSessionRecordScalarFieldEnum)[keyof typeof LearningSessionRecordScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    achievementType: 'achievementType',
    achievementValue: 'achievementValue',
    unlockedAt: 'unlockedAt',
    userId: 'userId'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const ReadingArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    summary: 'summary',
    difficulty: 'difficulty',
    wordCount: 'wordCount',
    readingTime: 'readingTime',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReadingArticleScalarFieldEnum = (typeof ReadingArticleScalarFieldEnum)[keyof typeof ReadingArticleScalarFieldEnum]


  export const UserReadingRecordScalarFieldEnum: {
    id: 'id',
    readingTime: 'readingTime',
    comprehension: 'comprehension',
    wordsLearned: 'wordsLearned',
    isCompleted: 'isCompleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    articleId: 'articleId'
  };

  export type UserReadingRecordScalarFieldEnum = (typeof UserReadingRecordScalarFieldEnum)[keyof typeof UserReadingRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    preferences?: StringFilter<"User"> | string
    vocabularies?: UserVocabularyListRelationFilter
    learningSessions?: LearningSessionListRelationFilter
    achievements?: UserAchievementListRelationFilter
    userReadingRecords?: UserReadingRecordListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    preferences?: SortOrder
    vocabularies?: UserVocabularyOrderByRelationAggregateInput
    learningSessions?: LearningSessionOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    userReadingRecords?: UserReadingRecordOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    preferences?: StringFilter<"User"> | string
    vocabularies?: UserVocabularyListRelationFilter
    learningSessions?: LearningSessionListRelationFilter
    achievements?: UserAchievementListRelationFilter
    userReadingRecords?: UserReadingRecordListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    preferences?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    preferences?: StringWithAggregatesFilter<"User"> | string
  }

  export type VocabularyCategoryWhereInput = {
    AND?: VocabularyCategoryWhereInput | VocabularyCategoryWhereInput[]
    OR?: VocabularyCategoryWhereInput[]
    NOT?: VocabularyCategoryWhereInput | VocabularyCategoryWhereInput[]
    id?: StringFilter<"VocabularyCategory"> | string
    name?: StringFilter<"VocabularyCategory"> | string
    description?: StringNullableFilter<"VocabularyCategory"> | string | null
    isActive?: BoolFilter<"VocabularyCategory"> | boolean
    createdAt?: DateTimeFilter<"VocabularyCategory"> | Date | string
    updatedAt?: DateTimeFilter<"VocabularyCategory"> | Date | string
    vocabularies?: VocabularyListRelationFilter
  }

  export type VocabularyCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vocabularies?: VocabularyOrderByRelationAggregateInput
  }

  export type VocabularyCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: VocabularyCategoryWhereInput | VocabularyCategoryWhereInput[]
    OR?: VocabularyCategoryWhereInput[]
    NOT?: VocabularyCategoryWhereInput | VocabularyCategoryWhereInput[]
    description?: StringNullableFilter<"VocabularyCategory"> | string | null
    isActive?: BoolFilter<"VocabularyCategory"> | boolean
    createdAt?: DateTimeFilter<"VocabularyCategory"> | Date | string
    updatedAt?: DateTimeFilter<"VocabularyCategory"> | Date | string
    vocabularies?: VocabularyListRelationFilter
  }, "id" | "name">

  export type VocabularyCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VocabularyCategoryCountOrderByAggregateInput
    _max?: VocabularyCategoryMaxOrderByAggregateInput
    _min?: VocabularyCategoryMinOrderByAggregateInput
  }

  export type VocabularyCategoryScalarWhereWithAggregatesInput = {
    AND?: VocabularyCategoryScalarWhereWithAggregatesInput | VocabularyCategoryScalarWhereWithAggregatesInput[]
    OR?: VocabularyCategoryScalarWhereWithAggregatesInput[]
    NOT?: VocabularyCategoryScalarWhereWithAggregatesInput | VocabularyCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VocabularyCategory"> | string
    name?: StringWithAggregatesFilter<"VocabularyCategory"> | string
    description?: StringNullableWithAggregatesFilter<"VocabularyCategory"> | string | null
    isActive?: BoolWithAggregatesFilter<"VocabularyCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"VocabularyCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VocabularyCategory"> | Date | string
  }

  export type VocabularyWhereInput = {
    AND?: VocabularyWhereInput | VocabularyWhereInput[]
    OR?: VocabularyWhereInput[]
    NOT?: VocabularyWhereInput | VocabularyWhereInput[]
    id?: StringFilter<"Vocabulary"> | string
    word?: StringFilter<"Vocabulary"> | string
    pronunciation?: StringNullableFilter<"Vocabulary"> | string | null
    definition?: StringFilter<"Vocabulary"> | string
    example?: StringNullableFilter<"Vocabulary"> | string | null
    difficulty?: IntFilter<"Vocabulary"> | number
    frequency?: IntFilter<"Vocabulary"> | number
    isActive?: BoolFilter<"Vocabulary"> | boolean
    createdAt?: DateTimeFilter<"Vocabulary"> | Date | string
    updatedAt?: DateTimeFilter<"Vocabulary"> | Date | string
    categoryId?: StringFilter<"Vocabulary"> | string
    category?: XOR<VocabularyCategoryRelationFilter, VocabularyCategoryWhereInput>
    userVocabularies?: UserVocabularyListRelationFilter
    sessionRecords?: LearningSessionRecordListRelationFilter
  }

  export type VocabularyOrderByWithRelationInput = {
    id?: SortOrder
    word?: SortOrder
    pronunciation?: SortOrderInput | SortOrder
    definition?: SortOrder
    example?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
    category?: VocabularyCategoryOrderByWithRelationInput
    userVocabularies?: UserVocabularyOrderByRelationAggregateInput
    sessionRecords?: LearningSessionRecordOrderByRelationAggregateInput
  }

  export type VocabularyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    word_categoryId?: VocabularyWordCategoryIdCompoundUniqueInput
    AND?: VocabularyWhereInput | VocabularyWhereInput[]
    OR?: VocabularyWhereInput[]
    NOT?: VocabularyWhereInput | VocabularyWhereInput[]
    word?: StringFilter<"Vocabulary"> | string
    pronunciation?: StringNullableFilter<"Vocabulary"> | string | null
    definition?: StringFilter<"Vocabulary"> | string
    example?: StringNullableFilter<"Vocabulary"> | string | null
    difficulty?: IntFilter<"Vocabulary"> | number
    frequency?: IntFilter<"Vocabulary"> | number
    isActive?: BoolFilter<"Vocabulary"> | boolean
    createdAt?: DateTimeFilter<"Vocabulary"> | Date | string
    updatedAt?: DateTimeFilter<"Vocabulary"> | Date | string
    categoryId?: StringFilter<"Vocabulary"> | string
    category?: XOR<VocabularyCategoryRelationFilter, VocabularyCategoryWhereInput>
    userVocabularies?: UserVocabularyListRelationFilter
    sessionRecords?: LearningSessionRecordListRelationFilter
  }, "id" | "word_categoryId">

  export type VocabularyOrderByWithAggregationInput = {
    id?: SortOrder
    word?: SortOrder
    pronunciation?: SortOrderInput | SortOrder
    definition?: SortOrder
    example?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
    _count?: VocabularyCountOrderByAggregateInput
    _avg?: VocabularyAvgOrderByAggregateInput
    _max?: VocabularyMaxOrderByAggregateInput
    _min?: VocabularyMinOrderByAggregateInput
    _sum?: VocabularySumOrderByAggregateInput
  }

  export type VocabularyScalarWhereWithAggregatesInput = {
    AND?: VocabularyScalarWhereWithAggregatesInput | VocabularyScalarWhereWithAggregatesInput[]
    OR?: VocabularyScalarWhereWithAggregatesInput[]
    NOT?: VocabularyScalarWhereWithAggregatesInput | VocabularyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vocabulary"> | string
    word?: StringWithAggregatesFilter<"Vocabulary"> | string
    pronunciation?: StringNullableWithAggregatesFilter<"Vocabulary"> | string | null
    definition?: StringWithAggregatesFilter<"Vocabulary"> | string
    example?: StringNullableWithAggregatesFilter<"Vocabulary"> | string | null
    difficulty?: IntWithAggregatesFilter<"Vocabulary"> | number
    frequency?: IntWithAggregatesFilter<"Vocabulary"> | number
    isActive?: BoolWithAggregatesFilter<"Vocabulary"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Vocabulary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vocabulary"> | Date | string
    categoryId?: StringWithAggregatesFilter<"Vocabulary"> | string
  }

  export type UserVocabularyWhereInput = {
    AND?: UserVocabularyWhereInput | UserVocabularyWhereInput[]
    OR?: UserVocabularyWhereInput[]
    NOT?: UserVocabularyWhereInput | UserVocabularyWhereInput[]
    id?: StringFilter<"UserVocabulary"> | string
    masteryLevel?: IntFilter<"UserVocabulary"> | number
    reviewCount?: IntFilter<"UserVocabulary"> | number
    correctCount?: IntFilter<"UserVocabulary"> | number
    consecutiveCorrect?: IntFilter<"UserVocabulary"> | number
    nextReviewAt?: DateTimeFilter<"UserVocabulary"> | Date | string
    lastReviewAt?: DateTimeNullableFilter<"UserVocabulary"> | Date | string | null
    createdAt?: DateTimeFilter<"UserVocabulary"> | Date | string
    updatedAt?: DateTimeFilter<"UserVocabulary"> | Date | string
    userId?: StringFilter<"UserVocabulary"> | string
    vocabularyId?: StringFilter<"UserVocabulary"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vocabulary?: XOR<VocabularyRelationFilter, VocabularyWhereInput>
  }

  export type UserVocabularyOrderByWithRelationInput = {
    id?: SortOrder
    masteryLevel?: SortOrder
    reviewCount?: SortOrder
    correctCount?: SortOrder
    consecutiveCorrect?: SortOrder
    nextReviewAt?: SortOrder
    lastReviewAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    vocabularyId?: SortOrder
    user?: UserOrderByWithRelationInput
    vocabulary?: VocabularyOrderByWithRelationInput
  }

  export type UserVocabularyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_vocabularyId?: UserVocabularyUserIdVocabularyIdCompoundUniqueInput
    AND?: UserVocabularyWhereInput | UserVocabularyWhereInput[]
    OR?: UserVocabularyWhereInput[]
    NOT?: UserVocabularyWhereInput | UserVocabularyWhereInput[]
    masteryLevel?: IntFilter<"UserVocabulary"> | number
    reviewCount?: IntFilter<"UserVocabulary"> | number
    correctCount?: IntFilter<"UserVocabulary"> | number
    consecutiveCorrect?: IntFilter<"UserVocabulary"> | number
    nextReviewAt?: DateTimeFilter<"UserVocabulary"> | Date | string
    lastReviewAt?: DateTimeNullableFilter<"UserVocabulary"> | Date | string | null
    createdAt?: DateTimeFilter<"UserVocabulary"> | Date | string
    updatedAt?: DateTimeFilter<"UserVocabulary"> | Date | string
    userId?: StringFilter<"UserVocabulary"> | string
    vocabularyId?: StringFilter<"UserVocabulary"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vocabulary?: XOR<VocabularyRelationFilter, VocabularyWhereInput>
  }, "id" | "userId_vocabularyId">

  export type UserVocabularyOrderByWithAggregationInput = {
    id?: SortOrder
    masteryLevel?: SortOrder
    reviewCount?: SortOrder
    correctCount?: SortOrder
    consecutiveCorrect?: SortOrder
    nextReviewAt?: SortOrder
    lastReviewAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    vocabularyId?: SortOrder
    _count?: UserVocabularyCountOrderByAggregateInput
    _avg?: UserVocabularyAvgOrderByAggregateInput
    _max?: UserVocabularyMaxOrderByAggregateInput
    _min?: UserVocabularyMinOrderByAggregateInput
    _sum?: UserVocabularySumOrderByAggregateInput
  }

  export type UserVocabularyScalarWhereWithAggregatesInput = {
    AND?: UserVocabularyScalarWhereWithAggregatesInput | UserVocabularyScalarWhereWithAggregatesInput[]
    OR?: UserVocabularyScalarWhereWithAggregatesInput[]
    NOT?: UserVocabularyScalarWhereWithAggregatesInput | UserVocabularyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserVocabulary"> | string
    masteryLevel?: IntWithAggregatesFilter<"UserVocabulary"> | number
    reviewCount?: IntWithAggregatesFilter<"UserVocabulary"> | number
    correctCount?: IntWithAggregatesFilter<"UserVocabulary"> | number
    consecutiveCorrect?: IntWithAggregatesFilter<"UserVocabulary"> | number
    nextReviewAt?: DateTimeWithAggregatesFilter<"UserVocabulary"> | Date | string
    lastReviewAt?: DateTimeNullableWithAggregatesFilter<"UserVocabulary"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserVocabulary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserVocabulary"> | Date | string
    userId?: StringWithAggregatesFilter<"UserVocabulary"> | string
    vocabularyId?: StringWithAggregatesFilter<"UserVocabulary"> | string
  }

  export type LearningSessionWhereInput = {
    AND?: LearningSessionWhereInput | LearningSessionWhereInput[]
    OR?: LearningSessionWhereInput[]
    NOT?: LearningSessionWhereInput | LearningSessionWhereInput[]
    id?: StringFilter<"LearningSession"> | string
    sessionType?: StringFilter<"LearningSession"> | string
    startTime?: DateTimeFilter<"LearningSession"> | Date | string
    endTime?: DateTimeNullableFilter<"LearningSession"> | Date | string | null
    totalWords?: IntFilter<"LearningSession"> | number
    correctAnswers?: IntFilter<"LearningSession"> | number
    timeSpent?: IntFilter<"LearningSession"> | number
    isActive?: BoolFilter<"LearningSession"> | boolean
    createdAt?: DateTimeFilter<"LearningSession"> | Date | string
    updatedAt?: DateTimeFilter<"LearningSession"> | Date | string
    userId?: StringFilter<"LearningSession"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    sessionRecords?: LearningSessionRecordListRelationFilter
  }

  export type LearningSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    totalWords?: SortOrder
    correctAnswers?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    sessionRecords?: LearningSessionRecordOrderByRelationAggregateInput
  }

  export type LearningSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningSessionWhereInput | LearningSessionWhereInput[]
    OR?: LearningSessionWhereInput[]
    NOT?: LearningSessionWhereInput | LearningSessionWhereInput[]
    sessionType?: StringFilter<"LearningSession"> | string
    startTime?: DateTimeFilter<"LearningSession"> | Date | string
    endTime?: DateTimeNullableFilter<"LearningSession"> | Date | string | null
    totalWords?: IntFilter<"LearningSession"> | number
    correctAnswers?: IntFilter<"LearningSession"> | number
    timeSpent?: IntFilter<"LearningSession"> | number
    isActive?: BoolFilter<"LearningSession"> | boolean
    createdAt?: DateTimeFilter<"LearningSession"> | Date | string
    updatedAt?: DateTimeFilter<"LearningSession"> | Date | string
    userId?: StringFilter<"LearningSession"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    sessionRecords?: LearningSessionRecordListRelationFilter
  }, "id">

  export type LearningSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    totalWords?: SortOrder
    correctAnswers?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: LearningSessionCountOrderByAggregateInput
    _avg?: LearningSessionAvgOrderByAggregateInput
    _max?: LearningSessionMaxOrderByAggregateInput
    _min?: LearningSessionMinOrderByAggregateInput
    _sum?: LearningSessionSumOrderByAggregateInput
  }

  export type LearningSessionScalarWhereWithAggregatesInput = {
    AND?: LearningSessionScalarWhereWithAggregatesInput | LearningSessionScalarWhereWithAggregatesInput[]
    OR?: LearningSessionScalarWhereWithAggregatesInput[]
    NOT?: LearningSessionScalarWhereWithAggregatesInput | LearningSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningSession"> | string
    sessionType?: StringWithAggregatesFilter<"LearningSession"> | string
    startTime?: DateTimeWithAggregatesFilter<"LearningSession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"LearningSession"> | Date | string | null
    totalWords?: IntWithAggregatesFilter<"LearningSession"> | number
    correctAnswers?: IntWithAggregatesFilter<"LearningSession"> | number
    timeSpent?: IntWithAggregatesFilter<"LearningSession"> | number
    isActive?: BoolWithAggregatesFilter<"LearningSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LearningSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LearningSession"> | Date | string
    userId?: StringWithAggregatesFilter<"LearningSession"> | string
  }

  export type LearningSessionRecordWhereInput = {
    AND?: LearningSessionRecordWhereInput | LearningSessionRecordWhereInput[]
    OR?: LearningSessionRecordWhereInput[]
    NOT?: LearningSessionRecordWhereInput | LearningSessionRecordWhereInput[]
    id?: StringFilter<"LearningSessionRecord"> | string
    isCorrect?: BoolFilter<"LearningSessionRecord"> | boolean
    responseTime?: IntFilter<"LearningSessionRecord"> | number
    difficulty?: IntFilter<"LearningSessionRecord"> | number
    createdAt?: DateTimeFilter<"LearningSessionRecord"> | Date | string
    sessionId?: StringFilter<"LearningSessionRecord"> | string
    vocabularyId?: StringFilter<"LearningSessionRecord"> | string
    session?: XOR<LearningSessionRelationFilter, LearningSessionWhereInput>
    vocabulary?: XOR<VocabularyRelationFilter, VocabularyWhereInput>
  }

  export type LearningSessionRecordOrderByWithRelationInput = {
    id?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    vocabularyId?: SortOrder
    session?: LearningSessionOrderByWithRelationInput
    vocabulary?: VocabularyOrderByWithRelationInput
  }

  export type LearningSessionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningSessionRecordWhereInput | LearningSessionRecordWhereInput[]
    OR?: LearningSessionRecordWhereInput[]
    NOT?: LearningSessionRecordWhereInput | LearningSessionRecordWhereInput[]
    isCorrect?: BoolFilter<"LearningSessionRecord"> | boolean
    responseTime?: IntFilter<"LearningSessionRecord"> | number
    difficulty?: IntFilter<"LearningSessionRecord"> | number
    createdAt?: DateTimeFilter<"LearningSessionRecord"> | Date | string
    sessionId?: StringFilter<"LearningSessionRecord"> | string
    vocabularyId?: StringFilter<"LearningSessionRecord"> | string
    session?: XOR<LearningSessionRelationFilter, LearningSessionWhereInput>
    vocabulary?: XOR<VocabularyRelationFilter, VocabularyWhereInput>
  }, "id">

  export type LearningSessionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    vocabularyId?: SortOrder
    _count?: LearningSessionRecordCountOrderByAggregateInput
    _avg?: LearningSessionRecordAvgOrderByAggregateInput
    _max?: LearningSessionRecordMaxOrderByAggregateInput
    _min?: LearningSessionRecordMinOrderByAggregateInput
    _sum?: LearningSessionRecordSumOrderByAggregateInput
  }

  export type LearningSessionRecordScalarWhereWithAggregatesInput = {
    AND?: LearningSessionRecordScalarWhereWithAggregatesInput | LearningSessionRecordScalarWhereWithAggregatesInput[]
    OR?: LearningSessionRecordScalarWhereWithAggregatesInput[]
    NOT?: LearningSessionRecordScalarWhereWithAggregatesInput | LearningSessionRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningSessionRecord"> | string
    isCorrect?: BoolWithAggregatesFilter<"LearningSessionRecord"> | boolean
    responseTime?: IntWithAggregatesFilter<"LearningSessionRecord"> | number
    difficulty?: IntWithAggregatesFilter<"LearningSessionRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LearningSessionRecord"> | Date | string
    sessionId?: StringWithAggregatesFilter<"LearningSessionRecord"> | string
    vocabularyId?: StringWithAggregatesFilter<"LearningSessionRecord"> | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    achievementType?: StringFilter<"UserAchievement"> | string
    achievementValue?: IntFilter<"UserAchievement"> | number
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    userId?: StringFilter<"UserAchievement"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    achievementType?: SortOrder
    achievementValue?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementType_achievementValue?: UserAchievementUserIdAchievementTypeAchievementValueCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    achievementType?: StringFilter<"UserAchievement"> | string
    achievementValue?: IntFilter<"UserAchievement"> | number
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    userId?: StringFilter<"UserAchievement"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_achievementType_achievementValue">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    achievementType?: SortOrder
    achievementValue?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementType?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementValue?: IntWithAggregatesFilter<"UserAchievement"> | number
    unlockedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
  }

  export type ReadingArticleWhereInput = {
    AND?: ReadingArticleWhereInput | ReadingArticleWhereInput[]
    OR?: ReadingArticleWhereInput[]
    NOT?: ReadingArticleWhereInput | ReadingArticleWhereInput[]
    id?: StringFilter<"ReadingArticle"> | string
    title?: StringFilter<"ReadingArticle"> | string
    content?: StringFilter<"ReadingArticle"> | string
    summary?: StringNullableFilter<"ReadingArticle"> | string | null
    difficulty?: IntFilter<"ReadingArticle"> | number
    wordCount?: IntFilter<"ReadingArticle"> | number
    readingTime?: IntFilter<"ReadingArticle"> | number
    isActive?: BoolFilter<"ReadingArticle"> | boolean
    createdAt?: DateTimeFilter<"ReadingArticle"> | Date | string
    updatedAt?: DateTimeFilter<"ReadingArticle"> | Date | string
    userReadingRecords?: UserReadingRecordListRelationFilter
  }

  export type ReadingArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userReadingRecords?: UserReadingRecordOrderByRelationAggregateInput
  }

  export type ReadingArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReadingArticleWhereInput | ReadingArticleWhereInput[]
    OR?: ReadingArticleWhereInput[]
    NOT?: ReadingArticleWhereInput | ReadingArticleWhereInput[]
    title?: StringFilter<"ReadingArticle"> | string
    content?: StringFilter<"ReadingArticle"> | string
    summary?: StringNullableFilter<"ReadingArticle"> | string | null
    difficulty?: IntFilter<"ReadingArticle"> | number
    wordCount?: IntFilter<"ReadingArticle"> | number
    readingTime?: IntFilter<"ReadingArticle"> | number
    isActive?: BoolFilter<"ReadingArticle"> | boolean
    createdAt?: DateTimeFilter<"ReadingArticle"> | Date | string
    updatedAt?: DateTimeFilter<"ReadingArticle"> | Date | string
    userReadingRecords?: UserReadingRecordListRelationFilter
  }, "id">

  export type ReadingArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReadingArticleCountOrderByAggregateInput
    _avg?: ReadingArticleAvgOrderByAggregateInput
    _max?: ReadingArticleMaxOrderByAggregateInput
    _min?: ReadingArticleMinOrderByAggregateInput
    _sum?: ReadingArticleSumOrderByAggregateInput
  }

  export type ReadingArticleScalarWhereWithAggregatesInput = {
    AND?: ReadingArticleScalarWhereWithAggregatesInput | ReadingArticleScalarWhereWithAggregatesInput[]
    OR?: ReadingArticleScalarWhereWithAggregatesInput[]
    NOT?: ReadingArticleScalarWhereWithAggregatesInput | ReadingArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReadingArticle"> | string
    title?: StringWithAggregatesFilter<"ReadingArticle"> | string
    content?: StringWithAggregatesFilter<"ReadingArticle"> | string
    summary?: StringNullableWithAggregatesFilter<"ReadingArticle"> | string | null
    difficulty?: IntWithAggregatesFilter<"ReadingArticle"> | number
    wordCount?: IntWithAggregatesFilter<"ReadingArticle"> | number
    readingTime?: IntWithAggregatesFilter<"ReadingArticle"> | number
    isActive?: BoolWithAggregatesFilter<"ReadingArticle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ReadingArticle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReadingArticle"> | Date | string
  }

  export type UserReadingRecordWhereInput = {
    AND?: UserReadingRecordWhereInput | UserReadingRecordWhereInput[]
    OR?: UserReadingRecordWhereInput[]
    NOT?: UserReadingRecordWhereInput | UserReadingRecordWhereInput[]
    id?: StringFilter<"UserReadingRecord"> | string
    readingTime?: IntFilter<"UserReadingRecord"> | number
    comprehension?: FloatFilter<"UserReadingRecord"> | number
    wordsLearned?: IntFilter<"UserReadingRecord"> | number
    isCompleted?: BoolFilter<"UserReadingRecord"> | boolean
    createdAt?: DateTimeFilter<"UserReadingRecord"> | Date | string
    updatedAt?: DateTimeFilter<"UserReadingRecord"> | Date | string
    userId?: StringFilter<"UserReadingRecord"> | string
    articleId?: StringFilter<"UserReadingRecord"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    article?: XOR<ReadingArticleRelationFilter, ReadingArticleWhereInput>
  }

  export type UserReadingRecordOrderByWithRelationInput = {
    id?: SortOrder
    readingTime?: SortOrder
    comprehension?: SortOrder
    wordsLearned?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    user?: UserOrderByWithRelationInput
    article?: ReadingArticleOrderByWithRelationInput
  }

  export type UserReadingRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_articleId?: UserReadingRecordUserIdArticleIdCompoundUniqueInput
    AND?: UserReadingRecordWhereInput | UserReadingRecordWhereInput[]
    OR?: UserReadingRecordWhereInput[]
    NOT?: UserReadingRecordWhereInput | UserReadingRecordWhereInput[]
    readingTime?: IntFilter<"UserReadingRecord"> | number
    comprehension?: FloatFilter<"UserReadingRecord"> | number
    wordsLearned?: IntFilter<"UserReadingRecord"> | number
    isCompleted?: BoolFilter<"UserReadingRecord"> | boolean
    createdAt?: DateTimeFilter<"UserReadingRecord"> | Date | string
    updatedAt?: DateTimeFilter<"UserReadingRecord"> | Date | string
    userId?: StringFilter<"UserReadingRecord"> | string
    articleId?: StringFilter<"UserReadingRecord"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    article?: XOR<ReadingArticleRelationFilter, ReadingArticleWhereInput>
  }, "id" | "userId_articleId">

  export type UserReadingRecordOrderByWithAggregationInput = {
    id?: SortOrder
    readingTime?: SortOrder
    comprehension?: SortOrder
    wordsLearned?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    _count?: UserReadingRecordCountOrderByAggregateInput
    _avg?: UserReadingRecordAvgOrderByAggregateInput
    _max?: UserReadingRecordMaxOrderByAggregateInput
    _min?: UserReadingRecordMinOrderByAggregateInput
    _sum?: UserReadingRecordSumOrderByAggregateInput
  }

  export type UserReadingRecordScalarWhereWithAggregatesInput = {
    AND?: UserReadingRecordScalarWhereWithAggregatesInput | UserReadingRecordScalarWhereWithAggregatesInput[]
    OR?: UserReadingRecordScalarWhereWithAggregatesInput[]
    NOT?: UserReadingRecordScalarWhereWithAggregatesInput | UserReadingRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserReadingRecord"> | string
    readingTime?: IntWithAggregatesFilter<"UserReadingRecord"> | number
    comprehension?: FloatWithAggregatesFilter<"UserReadingRecord"> | number
    wordsLearned?: IntWithAggregatesFilter<"UserReadingRecord"> | number
    isCompleted?: BoolWithAggregatesFilter<"UserReadingRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserReadingRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserReadingRecord"> | Date | string
    userId?: StringWithAggregatesFilter<"UserReadingRecord"> | string
    articleId?: StringWithAggregatesFilter<"UserReadingRecord"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    vocabularies?: UserVocabularyCreateNestedManyWithoutUserInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userReadingRecords?: UserReadingRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    vocabularies?: UserVocabularyUncheckedCreateNestedManyWithoutUserInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userReadingRecords?: UserReadingRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    vocabularies?: UserVocabularyUpdateManyWithoutUserNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userReadingRecords?: UserReadingRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    vocabularies?: UserVocabularyUncheckedUpdateManyWithoutUserNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userReadingRecords?: UserReadingRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vocabularies?: VocabularyCreateNestedManyWithoutCategoryInput
  }

  export type VocabularyCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vocabularies?: VocabularyUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type VocabularyCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vocabularies?: VocabularyUpdateManyWithoutCategoryNestedInput
  }

  export type VocabularyCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vocabularies?: VocabularyUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type VocabularyCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VocabularyCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VocabularyCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VocabularyCreateInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: VocabularyCategoryCreateNestedOneWithoutVocabulariesInput
    userVocabularies?: UserVocabularyCreateNestedManyWithoutVocabularyInput
    sessionRecords?: LearningSessionRecordCreateNestedManyWithoutVocabularyInput
  }

  export type VocabularyUncheckedCreateInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
    userVocabularies?: UserVocabularyUncheckedCreateNestedManyWithoutVocabularyInput
    sessionRecords?: LearningSessionRecordUncheckedCreateNestedManyWithoutVocabularyInput
  }

  export type VocabularyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: VocabularyCategoryUpdateOneRequiredWithoutVocabulariesNestedInput
    userVocabularies?: UserVocabularyUpdateManyWithoutVocabularyNestedInput
    sessionRecords?: LearningSessionRecordUpdateManyWithoutVocabularyNestedInput
  }

  export type VocabularyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    userVocabularies?: UserVocabularyUncheckedUpdateManyWithoutVocabularyNestedInput
    sessionRecords?: LearningSessionRecordUncheckedUpdateManyWithoutVocabularyNestedInput
  }

  export type VocabularyCreateManyInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
  }

  export type VocabularyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VocabularyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type UserVocabularyCreateInput = {
    id?: string
    masteryLevel?: number
    reviewCount?: number
    correctCount?: number
    consecutiveCorrect?: number
    nextReviewAt?: Date | string
    lastReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVocabulariesInput
    vocabulary: VocabularyCreateNestedOneWithoutUserVocabulariesInput
  }

  export type UserVocabularyUncheckedCreateInput = {
    id?: string
    masteryLevel?: number
    reviewCount?: number
    correctCount?: number
    consecutiveCorrect?: number
    nextReviewAt?: Date | string
    lastReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    vocabularyId: string
  }

  export type UserVocabularyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVocabulariesNestedInput
    vocabulary?: VocabularyUpdateOneRequiredWithoutUserVocabulariesNestedInput
  }

  export type UserVocabularyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    vocabularyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserVocabularyCreateManyInput = {
    id?: string
    masteryLevel?: number
    reviewCount?: number
    correctCount?: number
    consecutiveCorrect?: number
    nextReviewAt?: Date | string
    lastReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    vocabularyId: string
  }

  export type UserVocabularyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVocabularyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    vocabularyId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningSessionCreateInput = {
    id?: string
    sessionType: string
    startTime?: Date | string
    endTime?: Date | string | null
    totalWords?: number
    correctAnswers?: number
    timeSpent?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLearningSessionsInput
    sessionRecords?: LearningSessionRecordCreateNestedManyWithoutSessionInput
  }

  export type LearningSessionUncheckedCreateInput = {
    id?: string
    sessionType: string
    startTime?: Date | string
    endTime?: Date | string | null
    totalWords?: number
    correctAnswers?: number
    timeSpent?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    sessionRecords?: LearningSessionRecordUncheckedCreateNestedManyWithoutSessionInput
  }

  export type LearningSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalWords?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLearningSessionsNestedInput
    sessionRecords?: LearningSessionRecordUpdateManyWithoutSessionNestedInput
  }

  export type LearningSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalWords?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionRecords?: LearningSessionRecordUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type LearningSessionCreateManyInput = {
    id?: string
    sessionType: string
    startTime?: Date | string
    endTime?: Date | string | null
    totalWords?: number
    correctAnswers?: number
    timeSpent?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type LearningSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalWords?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalWords?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningSessionRecordCreateInput = {
    id?: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt?: Date | string
    session: LearningSessionCreateNestedOneWithoutSessionRecordsInput
    vocabulary: VocabularyCreateNestedOneWithoutSessionRecordsInput
  }

  export type LearningSessionRecordUncheckedCreateInput = {
    id?: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt?: Date | string
    sessionId: string
    vocabularyId: string
  }

  export type LearningSessionRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: LearningSessionUpdateOneRequiredWithoutSessionRecordsNestedInput
    vocabulary?: VocabularyUpdateOneRequiredWithoutSessionRecordsNestedInput
  }

  export type LearningSessionRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    vocabularyId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningSessionRecordCreateManyInput = {
    id?: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt?: Date | string
    sessionId: string
    vocabularyId: string
  }

  export type LearningSessionRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    vocabularyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    achievementType: string
    achievementValue: number
    unlockedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    achievementType: string
    achievementValue: number
    unlockedAt?: Date | string
    userId: string
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementValue?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementValue?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    achievementType: string
    achievementValue: number
    unlockedAt?: Date | string
    userId: string
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementValue?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementValue?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ReadingArticleCreateInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    difficulty?: number
    wordCount?: number
    readingTime?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userReadingRecords?: UserReadingRecordCreateNestedManyWithoutArticleInput
  }

  export type ReadingArticleUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    difficulty?: number
    wordCount?: number
    readingTime?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userReadingRecords?: UserReadingRecordUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ReadingArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    readingTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userReadingRecords?: UserReadingRecordUpdateManyWithoutArticleNestedInput
  }

  export type ReadingArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    readingTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userReadingRecords?: UserReadingRecordUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ReadingArticleCreateManyInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    difficulty?: number
    wordCount?: number
    readingTime?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReadingArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    readingTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    readingTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserReadingRecordCreateInput = {
    id?: string
    readingTime: number
    comprehension?: number
    wordsLearned?: number
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserReadingRecordsInput
    article: ReadingArticleCreateNestedOneWithoutUserReadingRecordsInput
  }

  export type UserReadingRecordUncheckedCreateInput = {
    id?: string
    readingTime: number
    comprehension?: number
    wordsLearned?: number
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    articleId: string
  }

  export type UserReadingRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserReadingRecordsNestedInput
    article?: ReadingArticleUpdateOneRequiredWithoutUserReadingRecordsNestedInput
  }

  export type UserReadingRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserReadingRecordCreateManyInput = {
    id?: string
    readingTime: number
    comprehension?: number
    wordsLearned?: number
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    articleId: string
  }

  export type UserReadingRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserReadingRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserVocabularyListRelationFilter = {
    every?: UserVocabularyWhereInput
    some?: UserVocabularyWhereInput
    none?: UserVocabularyWhereInput
  }

  export type LearningSessionListRelationFilter = {
    every?: LearningSessionWhereInput
    some?: LearningSessionWhereInput
    none?: LearningSessionWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type UserReadingRecordListRelationFilter = {
    every?: UserReadingRecordWhereInput
    some?: UserReadingRecordWhereInput
    none?: UserReadingRecordWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserVocabularyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserReadingRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    preferences?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    preferences?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    preferences?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type VocabularyListRelationFilter = {
    every?: VocabularyWhereInput
    some?: VocabularyWhereInput
    none?: VocabularyWhereInput
  }

  export type VocabularyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VocabularyCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VocabularyCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VocabularyCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type VocabularyCategoryRelationFilter = {
    is?: VocabularyCategoryWhereInput
    isNot?: VocabularyCategoryWhereInput
  }

  export type LearningSessionRecordListRelationFilter = {
    every?: LearningSessionRecordWhereInput
    some?: LearningSessionRecordWhereInput
    none?: LearningSessionRecordWhereInput
  }

  export type LearningSessionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VocabularyWordCategoryIdCompoundUniqueInput = {
    word: string
    categoryId: string
  }

  export type VocabularyCountOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    pronunciation?: SortOrder
    definition?: SortOrder
    example?: SortOrder
    difficulty?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type VocabularyAvgOrderByAggregateInput = {
    difficulty?: SortOrder
    frequency?: SortOrder
  }

  export type VocabularyMaxOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    pronunciation?: SortOrder
    definition?: SortOrder
    example?: SortOrder
    difficulty?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type VocabularyMinOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    pronunciation?: SortOrder
    definition?: SortOrder
    example?: SortOrder
    difficulty?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type VocabularySumOrderByAggregateInput = {
    difficulty?: SortOrder
    frequency?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VocabularyRelationFilter = {
    is?: VocabularyWhereInput
    isNot?: VocabularyWhereInput
  }

  export type UserVocabularyUserIdVocabularyIdCompoundUniqueInput = {
    userId: string
    vocabularyId: string
  }

  export type UserVocabularyCountOrderByAggregateInput = {
    id?: SortOrder
    masteryLevel?: SortOrder
    reviewCount?: SortOrder
    correctCount?: SortOrder
    consecutiveCorrect?: SortOrder
    nextReviewAt?: SortOrder
    lastReviewAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    vocabularyId?: SortOrder
  }

  export type UserVocabularyAvgOrderByAggregateInput = {
    masteryLevel?: SortOrder
    reviewCount?: SortOrder
    correctCount?: SortOrder
    consecutiveCorrect?: SortOrder
  }

  export type UserVocabularyMaxOrderByAggregateInput = {
    id?: SortOrder
    masteryLevel?: SortOrder
    reviewCount?: SortOrder
    correctCount?: SortOrder
    consecutiveCorrect?: SortOrder
    nextReviewAt?: SortOrder
    lastReviewAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    vocabularyId?: SortOrder
  }

  export type UserVocabularyMinOrderByAggregateInput = {
    id?: SortOrder
    masteryLevel?: SortOrder
    reviewCount?: SortOrder
    correctCount?: SortOrder
    consecutiveCorrect?: SortOrder
    nextReviewAt?: SortOrder
    lastReviewAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    vocabularyId?: SortOrder
  }

  export type UserVocabularySumOrderByAggregateInput = {
    masteryLevel?: SortOrder
    reviewCount?: SortOrder
    correctCount?: SortOrder
    consecutiveCorrect?: SortOrder
  }

  export type LearningSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    totalWords?: SortOrder
    correctAnswers?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type LearningSessionAvgOrderByAggregateInput = {
    totalWords?: SortOrder
    correctAnswers?: SortOrder
    timeSpent?: SortOrder
  }

  export type LearningSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    totalWords?: SortOrder
    correctAnswers?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type LearningSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    totalWords?: SortOrder
    correctAnswers?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type LearningSessionSumOrderByAggregateInput = {
    totalWords?: SortOrder
    correctAnswers?: SortOrder
    timeSpent?: SortOrder
  }

  export type LearningSessionRelationFilter = {
    is?: LearningSessionWhereInput
    isNot?: LearningSessionWhereInput
  }

  export type LearningSessionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    vocabularyId?: SortOrder
  }

  export type LearningSessionRecordAvgOrderByAggregateInput = {
    responseTime?: SortOrder
    difficulty?: SortOrder
  }

  export type LearningSessionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    vocabularyId?: SortOrder
  }

  export type LearningSessionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    vocabularyId?: SortOrder
  }

  export type LearningSessionRecordSumOrderByAggregateInput = {
    responseTime?: SortOrder
    difficulty?: SortOrder
  }

  export type UserAchievementUserIdAchievementTypeAchievementValueCompoundUniqueInput = {
    userId: string
    achievementType: string
    achievementValue: number
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    achievementType?: SortOrder
    achievementValue?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    achievementValue?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    achievementType?: SortOrder
    achievementValue?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    achievementType?: SortOrder
    achievementValue?: SortOrder
    unlockedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    achievementValue?: SortOrder
  }

  export type ReadingArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    difficulty?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReadingArticleAvgOrderByAggregateInput = {
    difficulty?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
  }

  export type ReadingArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    difficulty?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReadingArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    difficulty?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReadingArticleSumOrderByAggregateInput = {
    difficulty?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ReadingArticleRelationFilter = {
    is?: ReadingArticleWhereInput
    isNot?: ReadingArticleWhereInput
  }

  export type UserReadingRecordUserIdArticleIdCompoundUniqueInput = {
    userId: string
    articleId: string
  }

  export type UserReadingRecordCountOrderByAggregateInput = {
    id?: SortOrder
    readingTime?: SortOrder
    comprehension?: SortOrder
    wordsLearned?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type UserReadingRecordAvgOrderByAggregateInput = {
    readingTime?: SortOrder
    comprehension?: SortOrder
    wordsLearned?: SortOrder
  }

  export type UserReadingRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    readingTime?: SortOrder
    comprehension?: SortOrder
    wordsLearned?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type UserReadingRecordMinOrderByAggregateInput = {
    id?: SortOrder
    readingTime?: SortOrder
    comprehension?: SortOrder
    wordsLearned?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type UserReadingRecordSumOrderByAggregateInput = {
    readingTime?: SortOrder
    comprehension?: SortOrder
    wordsLearned?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserVocabularyCreateNestedManyWithoutUserInput = {
    create?: XOR<UserVocabularyCreateWithoutUserInput, UserVocabularyUncheckedCreateWithoutUserInput> | UserVocabularyCreateWithoutUserInput[] | UserVocabularyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserVocabularyCreateOrConnectWithoutUserInput | UserVocabularyCreateOrConnectWithoutUserInput[]
    createMany?: UserVocabularyCreateManyUserInputEnvelope
    connect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
  }

  export type LearningSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserReadingRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<UserReadingRecordCreateWithoutUserInput, UserReadingRecordUncheckedCreateWithoutUserInput> | UserReadingRecordCreateWithoutUserInput[] | UserReadingRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserReadingRecordCreateOrConnectWithoutUserInput | UserReadingRecordCreateOrConnectWithoutUserInput[]
    createMany?: UserReadingRecordCreateManyUserInputEnvelope
    connect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
  }

  export type UserVocabularyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserVocabularyCreateWithoutUserInput, UserVocabularyUncheckedCreateWithoutUserInput> | UserVocabularyCreateWithoutUserInput[] | UserVocabularyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserVocabularyCreateOrConnectWithoutUserInput | UserVocabularyCreateOrConnectWithoutUserInput[]
    createMany?: UserVocabularyCreateManyUserInputEnvelope
    connect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
  }

  export type LearningSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserReadingRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserReadingRecordCreateWithoutUserInput, UserReadingRecordUncheckedCreateWithoutUserInput> | UserReadingRecordCreateWithoutUserInput[] | UserReadingRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserReadingRecordCreateOrConnectWithoutUserInput | UserReadingRecordCreateOrConnectWithoutUserInput[]
    createMany?: UserReadingRecordCreateManyUserInputEnvelope
    connect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserVocabularyUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserVocabularyCreateWithoutUserInput, UserVocabularyUncheckedCreateWithoutUserInput> | UserVocabularyCreateWithoutUserInput[] | UserVocabularyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserVocabularyCreateOrConnectWithoutUserInput | UserVocabularyCreateOrConnectWithoutUserInput[]
    upsert?: UserVocabularyUpsertWithWhereUniqueWithoutUserInput | UserVocabularyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserVocabularyCreateManyUserInputEnvelope
    set?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    disconnect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    delete?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    connect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    update?: UserVocabularyUpdateWithWhereUniqueWithoutUserInput | UserVocabularyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserVocabularyUpdateManyWithWhereWithoutUserInput | UserVocabularyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserVocabularyScalarWhereInput | UserVocabularyScalarWhereInput[]
  }

  export type LearningSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutUserInput | LearningSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutUserInput | LearningSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutUserInput | LearningSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserReadingRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserReadingRecordCreateWithoutUserInput, UserReadingRecordUncheckedCreateWithoutUserInput> | UserReadingRecordCreateWithoutUserInput[] | UserReadingRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserReadingRecordCreateOrConnectWithoutUserInput | UserReadingRecordCreateOrConnectWithoutUserInput[]
    upsert?: UserReadingRecordUpsertWithWhereUniqueWithoutUserInput | UserReadingRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserReadingRecordCreateManyUserInputEnvelope
    set?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    disconnect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    delete?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    connect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    update?: UserReadingRecordUpdateWithWhereUniqueWithoutUserInput | UserReadingRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserReadingRecordUpdateManyWithWhereWithoutUserInput | UserReadingRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserReadingRecordScalarWhereInput | UserReadingRecordScalarWhereInput[]
  }

  export type UserVocabularyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserVocabularyCreateWithoutUserInput, UserVocabularyUncheckedCreateWithoutUserInput> | UserVocabularyCreateWithoutUserInput[] | UserVocabularyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserVocabularyCreateOrConnectWithoutUserInput | UserVocabularyCreateOrConnectWithoutUserInput[]
    upsert?: UserVocabularyUpsertWithWhereUniqueWithoutUserInput | UserVocabularyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserVocabularyCreateManyUserInputEnvelope
    set?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    disconnect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    delete?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    connect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    update?: UserVocabularyUpdateWithWhereUniqueWithoutUserInput | UserVocabularyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserVocabularyUpdateManyWithWhereWithoutUserInput | UserVocabularyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserVocabularyScalarWhereInput | UserVocabularyScalarWhereInput[]
  }

  export type LearningSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutUserInput | LearningSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutUserInput | LearningSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutUserInput | LearningSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserReadingRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserReadingRecordCreateWithoutUserInput, UserReadingRecordUncheckedCreateWithoutUserInput> | UserReadingRecordCreateWithoutUserInput[] | UserReadingRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserReadingRecordCreateOrConnectWithoutUserInput | UserReadingRecordCreateOrConnectWithoutUserInput[]
    upsert?: UserReadingRecordUpsertWithWhereUniqueWithoutUserInput | UserReadingRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserReadingRecordCreateManyUserInputEnvelope
    set?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    disconnect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    delete?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    connect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    update?: UserReadingRecordUpdateWithWhereUniqueWithoutUserInput | UserReadingRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserReadingRecordUpdateManyWithWhereWithoutUserInput | UserReadingRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserReadingRecordScalarWhereInput | UserReadingRecordScalarWhereInput[]
  }

  export type VocabularyCreateNestedManyWithoutCategoryInput = {
    create?: XOR<VocabularyCreateWithoutCategoryInput, VocabularyUncheckedCreateWithoutCategoryInput> | VocabularyCreateWithoutCategoryInput[] | VocabularyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VocabularyCreateOrConnectWithoutCategoryInput | VocabularyCreateOrConnectWithoutCategoryInput[]
    createMany?: VocabularyCreateManyCategoryInputEnvelope
    connect?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
  }

  export type VocabularyUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<VocabularyCreateWithoutCategoryInput, VocabularyUncheckedCreateWithoutCategoryInput> | VocabularyCreateWithoutCategoryInput[] | VocabularyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VocabularyCreateOrConnectWithoutCategoryInput | VocabularyCreateOrConnectWithoutCategoryInput[]
    createMany?: VocabularyCreateManyCategoryInputEnvelope
    connect?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type VocabularyUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<VocabularyCreateWithoutCategoryInput, VocabularyUncheckedCreateWithoutCategoryInput> | VocabularyCreateWithoutCategoryInput[] | VocabularyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VocabularyCreateOrConnectWithoutCategoryInput | VocabularyCreateOrConnectWithoutCategoryInput[]
    upsert?: VocabularyUpsertWithWhereUniqueWithoutCategoryInput | VocabularyUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: VocabularyCreateManyCategoryInputEnvelope
    set?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
    disconnect?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
    delete?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
    connect?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
    update?: VocabularyUpdateWithWhereUniqueWithoutCategoryInput | VocabularyUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: VocabularyUpdateManyWithWhereWithoutCategoryInput | VocabularyUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: VocabularyScalarWhereInput | VocabularyScalarWhereInput[]
  }

  export type VocabularyUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<VocabularyCreateWithoutCategoryInput, VocabularyUncheckedCreateWithoutCategoryInput> | VocabularyCreateWithoutCategoryInput[] | VocabularyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VocabularyCreateOrConnectWithoutCategoryInput | VocabularyCreateOrConnectWithoutCategoryInput[]
    upsert?: VocabularyUpsertWithWhereUniqueWithoutCategoryInput | VocabularyUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: VocabularyCreateManyCategoryInputEnvelope
    set?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
    disconnect?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
    delete?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
    connect?: VocabularyWhereUniqueInput | VocabularyWhereUniqueInput[]
    update?: VocabularyUpdateWithWhereUniqueWithoutCategoryInput | VocabularyUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: VocabularyUpdateManyWithWhereWithoutCategoryInput | VocabularyUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: VocabularyScalarWhereInput | VocabularyScalarWhereInput[]
  }

  export type VocabularyCategoryCreateNestedOneWithoutVocabulariesInput = {
    create?: XOR<VocabularyCategoryCreateWithoutVocabulariesInput, VocabularyCategoryUncheckedCreateWithoutVocabulariesInput>
    connectOrCreate?: VocabularyCategoryCreateOrConnectWithoutVocabulariesInput
    connect?: VocabularyCategoryWhereUniqueInput
  }

  export type UserVocabularyCreateNestedManyWithoutVocabularyInput = {
    create?: XOR<UserVocabularyCreateWithoutVocabularyInput, UserVocabularyUncheckedCreateWithoutVocabularyInput> | UserVocabularyCreateWithoutVocabularyInput[] | UserVocabularyUncheckedCreateWithoutVocabularyInput[]
    connectOrCreate?: UserVocabularyCreateOrConnectWithoutVocabularyInput | UserVocabularyCreateOrConnectWithoutVocabularyInput[]
    createMany?: UserVocabularyCreateManyVocabularyInputEnvelope
    connect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
  }

  export type LearningSessionRecordCreateNestedManyWithoutVocabularyInput = {
    create?: XOR<LearningSessionRecordCreateWithoutVocabularyInput, LearningSessionRecordUncheckedCreateWithoutVocabularyInput> | LearningSessionRecordCreateWithoutVocabularyInput[] | LearningSessionRecordUncheckedCreateWithoutVocabularyInput[]
    connectOrCreate?: LearningSessionRecordCreateOrConnectWithoutVocabularyInput | LearningSessionRecordCreateOrConnectWithoutVocabularyInput[]
    createMany?: LearningSessionRecordCreateManyVocabularyInputEnvelope
    connect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
  }

  export type UserVocabularyUncheckedCreateNestedManyWithoutVocabularyInput = {
    create?: XOR<UserVocabularyCreateWithoutVocabularyInput, UserVocabularyUncheckedCreateWithoutVocabularyInput> | UserVocabularyCreateWithoutVocabularyInput[] | UserVocabularyUncheckedCreateWithoutVocabularyInput[]
    connectOrCreate?: UserVocabularyCreateOrConnectWithoutVocabularyInput | UserVocabularyCreateOrConnectWithoutVocabularyInput[]
    createMany?: UserVocabularyCreateManyVocabularyInputEnvelope
    connect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
  }

  export type LearningSessionRecordUncheckedCreateNestedManyWithoutVocabularyInput = {
    create?: XOR<LearningSessionRecordCreateWithoutVocabularyInput, LearningSessionRecordUncheckedCreateWithoutVocabularyInput> | LearningSessionRecordCreateWithoutVocabularyInput[] | LearningSessionRecordUncheckedCreateWithoutVocabularyInput[]
    connectOrCreate?: LearningSessionRecordCreateOrConnectWithoutVocabularyInput | LearningSessionRecordCreateOrConnectWithoutVocabularyInput[]
    createMany?: LearningSessionRecordCreateManyVocabularyInputEnvelope
    connect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VocabularyCategoryUpdateOneRequiredWithoutVocabulariesNestedInput = {
    create?: XOR<VocabularyCategoryCreateWithoutVocabulariesInput, VocabularyCategoryUncheckedCreateWithoutVocabulariesInput>
    connectOrCreate?: VocabularyCategoryCreateOrConnectWithoutVocabulariesInput
    upsert?: VocabularyCategoryUpsertWithoutVocabulariesInput
    connect?: VocabularyCategoryWhereUniqueInput
    update?: XOR<XOR<VocabularyCategoryUpdateToOneWithWhereWithoutVocabulariesInput, VocabularyCategoryUpdateWithoutVocabulariesInput>, VocabularyCategoryUncheckedUpdateWithoutVocabulariesInput>
  }

  export type UserVocabularyUpdateManyWithoutVocabularyNestedInput = {
    create?: XOR<UserVocabularyCreateWithoutVocabularyInput, UserVocabularyUncheckedCreateWithoutVocabularyInput> | UserVocabularyCreateWithoutVocabularyInput[] | UserVocabularyUncheckedCreateWithoutVocabularyInput[]
    connectOrCreate?: UserVocabularyCreateOrConnectWithoutVocabularyInput | UserVocabularyCreateOrConnectWithoutVocabularyInput[]
    upsert?: UserVocabularyUpsertWithWhereUniqueWithoutVocabularyInput | UserVocabularyUpsertWithWhereUniqueWithoutVocabularyInput[]
    createMany?: UserVocabularyCreateManyVocabularyInputEnvelope
    set?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    disconnect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    delete?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    connect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    update?: UserVocabularyUpdateWithWhereUniqueWithoutVocabularyInput | UserVocabularyUpdateWithWhereUniqueWithoutVocabularyInput[]
    updateMany?: UserVocabularyUpdateManyWithWhereWithoutVocabularyInput | UserVocabularyUpdateManyWithWhereWithoutVocabularyInput[]
    deleteMany?: UserVocabularyScalarWhereInput | UserVocabularyScalarWhereInput[]
  }

  export type LearningSessionRecordUpdateManyWithoutVocabularyNestedInput = {
    create?: XOR<LearningSessionRecordCreateWithoutVocabularyInput, LearningSessionRecordUncheckedCreateWithoutVocabularyInput> | LearningSessionRecordCreateWithoutVocabularyInput[] | LearningSessionRecordUncheckedCreateWithoutVocabularyInput[]
    connectOrCreate?: LearningSessionRecordCreateOrConnectWithoutVocabularyInput | LearningSessionRecordCreateOrConnectWithoutVocabularyInput[]
    upsert?: LearningSessionRecordUpsertWithWhereUniqueWithoutVocabularyInput | LearningSessionRecordUpsertWithWhereUniqueWithoutVocabularyInput[]
    createMany?: LearningSessionRecordCreateManyVocabularyInputEnvelope
    set?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    disconnect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    delete?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    connect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    update?: LearningSessionRecordUpdateWithWhereUniqueWithoutVocabularyInput | LearningSessionRecordUpdateWithWhereUniqueWithoutVocabularyInput[]
    updateMany?: LearningSessionRecordUpdateManyWithWhereWithoutVocabularyInput | LearningSessionRecordUpdateManyWithWhereWithoutVocabularyInput[]
    deleteMany?: LearningSessionRecordScalarWhereInput | LearningSessionRecordScalarWhereInput[]
  }

  export type UserVocabularyUncheckedUpdateManyWithoutVocabularyNestedInput = {
    create?: XOR<UserVocabularyCreateWithoutVocabularyInput, UserVocabularyUncheckedCreateWithoutVocabularyInput> | UserVocabularyCreateWithoutVocabularyInput[] | UserVocabularyUncheckedCreateWithoutVocabularyInput[]
    connectOrCreate?: UserVocabularyCreateOrConnectWithoutVocabularyInput | UserVocabularyCreateOrConnectWithoutVocabularyInput[]
    upsert?: UserVocabularyUpsertWithWhereUniqueWithoutVocabularyInput | UserVocabularyUpsertWithWhereUniqueWithoutVocabularyInput[]
    createMany?: UserVocabularyCreateManyVocabularyInputEnvelope
    set?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    disconnect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    delete?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    connect?: UserVocabularyWhereUniqueInput | UserVocabularyWhereUniqueInput[]
    update?: UserVocabularyUpdateWithWhereUniqueWithoutVocabularyInput | UserVocabularyUpdateWithWhereUniqueWithoutVocabularyInput[]
    updateMany?: UserVocabularyUpdateManyWithWhereWithoutVocabularyInput | UserVocabularyUpdateManyWithWhereWithoutVocabularyInput[]
    deleteMany?: UserVocabularyScalarWhereInput | UserVocabularyScalarWhereInput[]
  }

  export type LearningSessionRecordUncheckedUpdateManyWithoutVocabularyNestedInput = {
    create?: XOR<LearningSessionRecordCreateWithoutVocabularyInput, LearningSessionRecordUncheckedCreateWithoutVocabularyInput> | LearningSessionRecordCreateWithoutVocabularyInput[] | LearningSessionRecordUncheckedCreateWithoutVocabularyInput[]
    connectOrCreate?: LearningSessionRecordCreateOrConnectWithoutVocabularyInput | LearningSessionRecordCreateOrConnectWithoutVocabularyInput[]
    upsert?: LearningSessionRecordUpsertWithWhereUniqueWithoutVocabularyInput | LearningSessionRecordUpsertWithWhereUniqueWithoutVocabularyInput[]
    createMany?: LearningSessionRecordCreateManyVocabularyInputEnvelope
    set?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    disconnect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    delete?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    connect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    update?: LearningSessionRecordUpdateWithWhereUniqueWithoutVocabularyInput | LearningSessionRecordUpdateWithWhereUniqueWithoutVocabularyInput[]
    updateMany?: LearningSessionRecordUpdateManyWithWhereWithoutVocabularyInput | LearningSessionRecordUpdateManyWithWhereWithoutVocabularyInput[]
    deleteMany?: LearningSessionRecordScalarWhereInput | LearningSessionRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutVocabulariesInput = {
    create?: XOR<UserCreateWithoutVocabulariesInput, UserUncheckedCreateWithoutVocabulariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVocabulariesInput
    connect?: UserWhereUniqueInput
  }

  export type VocabularyCreateNestedOneWithoutUserVocabulariesInput = {
    create?: XOR<VocabularyCreateWithoutUserVocabulariesInput, VocabularyUncheckedCreateWithoutUserVocabulariesInput>
    connectOrCreate?: VocabularyCreateOrConnectWithoutUserVocabulariesInput
    connect?: VocabularyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVocabulariesNestedInput = {
    create?: XOR<UserCreateWithoutVocabulariesInput, UserUncheckedCreateWithoutVocabulariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVocabulariesInput
    upsert?: UserUpsertWithoutVocabulariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVocabulariesInput, UserUpdateWithoutVocabulariesInput>, UserUncheckedUpdateWithoutVocabulariesInput>
  }

  export type VocabularyUpdateOneRequiredWithoutUserVocabulariesNestedInput = {
    create?: XOR<VocabularyCreateWithoutUserVocabulariesInput, VocabularyUncheckedCreateWithoutUserVocabulariesInput>
    connectOrCreate?: VocabularyCreateOrConnectWithoutUserVocabulariesInput
    upsert?: VocabularyUpsertWithoutUserVocabulariesInput
    connect?: VocabularyWhereUniqueInput
    update?: XOR<XOR<VocabularyUpdateToOneWithWhereWithoutUserVocabulariesInput, VocabularyUpdateWithoutUserVocabulariesInput>, VocabularyUncheckedUpdateWithoutUserVocabulariesInput>
  }

  export type UserCreateNestedOneWithoutLearningSessionsInput = {
    create?: XOR<UserCreateWithoutLearningSessionsInput, UserUncheckedCreateWithoutLearningSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type LearningSessionRecordCreateNestedManyWithoutSessionInput = {
    create?: XOR<LearningSessionRecordCreateWithoutSessionInput, LearningSessionRecordUncheckedCreateWithoutSessionInput> | LearningSessionRecordCreateWithoutSessionInput[] | LearningSessionRecordUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LearningSessionRecordCreateOrConnectWithoutSessionInput | LearningSessionRecordCreateOrConnectWithoutSessionInput[]
    createMany?: LearningSessionRecordCreateManySessionInputEnvelope
    connect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
  }

  export type LearningSessionRecordUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<LearningSessionRecordCreateWithoutSessionInput, LearningSessionRecordUncheckedCreateWithoutSessionInput> | LearningSessionRecordCreateWithoutSessionInput[] | LearningSessionRecordUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LearningSessionRecordCreateOrConnectWithoutSessionInput | LearningSessionRecordCreateOrConnectWithoutSessionInput[]
    createMany?: LearningSessionRecordCreateManySessionInputEnvelope
    connect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLearningSessionsNestedInput = {
    create?: XOR<UserCreateWithoutLearningSessionsInput, UserUncheckedCreateWithoutLearningSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningSessionsInput
    upsert?: UserUpsertWithoutLearningSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLearningSessionsInput, UserUpdateWithoutLearningSessionsInput>, UserUncheckedUpdateWithoutLearningSessionsInput>
  }

  export type LearningSessionRecordUpdateManyWithoutSessionNestedInput = {
    create?: XOR<LearningSessionRecordCreateWithoutSessionInput, LearningSessionRecordUncheckedCreateWithoutSessionInput> | LearningSessionRecordCreateWithoutSessionInput[] | LearningSessionRecordUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LearningSessionRecordCreateOrConnectWithoutSessionInput | LearningSessionRecordCreateOrConnectWithoutSessionInput[]
    upsert?: LearningSessionRecordUpsertWithWhereUniqueWithoutSessionInput | LearningSessionRecordUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: LearningSessionRecordCreateManySessionInputEnvelope
    set?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    disconnect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    delete?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    connect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    update?: LearningSessionRecordUpdateWithWhereUniqueWithoutSessionInput | LearningSessionRecordUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: LearningSessionRecordUpdateManyWithWhereWithoutSessionInput | LearningSessionRecordUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: LearningSessionRecordScalarWhereInput | LearningSessionRecordScalarWhereInput[]
  }

  export type LearningSessionRecordUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<LearningSessionRecordCreateWithoutSessionInput, LearningSessionRecordUncheckedCreateWithoutSessionInput> | LearningSessionRecordCreateWithoutSessionInput[] | LearningSessionRecordUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LearningSessionRecordCreateOrConnectWithoutSessionInput | LearningSessionRecordCreateOrConnectWithoutSessionInput[]
    upsert?: LearningSessionRecordUpsertWithWhereUniqueWithoutSessionInput | LearningSessionRecordUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: LearningSessionRecordCreateManySessionInputEnvelope
    set?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    disconnect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    delete?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    connect?: LearningSessionRecordWhereUniqueInput | LearningSessionRecordWhereUniqueInput[]
    update?: LearningSessionRecordUpdateWithWhereUniqueWithoutSessionInput | LearningSessionRecordUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: LearningSessionRecordUpdateManyWithWhereWithoutSessionInput | LearningSessionRecordUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: LearningSessionRecordScalarWhereInput | LearningSessionRecordScalarWhereInput[]
  }

  export type LearningSessionCreateNestedOneWithoutSessionRecordsInput = {
    create?: XOR<LearningSessionCreateWithoutSessionRecordsInput, LearningSessionUncheckedCreateWithoutSessionRecordsInput>
    connectOrCreate?: LearningSessionCreateOrConnectWithoutSessionRecordsInput
    connect?: LearningSessionWhereUniqueInput
  }

  export type VocabularyCreateNestedOneWithoutSessionRecordsInput = {
    create?: XOR<VocabularyCreateWithoutSessionRecordsInput, VocabularyUncheckedCreateWithoutSessionRecordsInput>
    connectOrCreate?: VocabularyCreateOrConnectWithoutSessionRecordsInput
    connect?: VocabularyWhereUniqueInput
  }

  export type LearningSessionUpdateOneRequiredWithoutSessionRecordsNestedInput = {
    create?: XOR<LearningSessionCreateWithoutSessionRecordsInput, LearningSessionUncheckedCreateWithoutSessionRecordsInput>
    connectOrCreate?: LearningSessionCreateOrConnectWithoutSessionRecordsInput
    upsert?: LearningSessionUpsertWithoutSessionRecordsInput
    connect?: LearningSessionWhereUniqueInput
    update?: XOR<XOR<LearningSessionUpdateToOneWithWhereWithoutSessionRecordsInput, LearningSessionUpdateWithoutSessionRecordsInput>, LearningSessionUncheckedUpdateWithoutSessionRecordsInput>
  }

  export type VocabularyUpdateOneRequiredWithoutSessionRecordsNestedInput = {
    create?: XOR<VocabularyCreateWithoutSessionRecordsInput, VocabularyUncheckedCreateWithoutSessionRecordsInput>
    connectOrCreate?: VocabularyCreateOrConnectWithoutSessionRecordsInput
    upsert?: VocabularyUpsertWithoutSessionRecordsInput
    connect?: VocabularyWhereUniqueInput
    update?: XOR<XOR<VocabularyUpdateToOneWithWhereWithoutSessionRecordsInput, VocabularyUpdateWithoutSessionRecordsInput>, VocabularyUncheckedUpdateWithoutSessionRecordsInput>
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserReadingRecordCreateNestedManyWithoutArticleInput = {
    create?: XOR<UserReadingRecordCreateWithoutArticleInput, UserReadingRecordUncheckedCreateWithoutArticleInput> | UserReadingRecordCreateWithoutArticleInput[] | UserReadingRecordUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: UserReadingRecordCreateOrConnectWithoutArticleInput | UserReadingRecordCreateOrConnectWithoutArticleInput[]
    createMany?: UserReadingRecordCreateManyArticleInputEnvelope
    connect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
  }

  export type UserReadingRecordUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<UserReadingRecordCreateWithoutArticleInput, UserReadingRecordUncheckedCreateWithoutArticleInput> | UserReadingRecordCreateWithoutArticleInput[] | UserReadingRecordUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: UserReadingRecordCreateOrConnectWithoutArticleInput | UserReadingRecordCreateOrConnectWithoutArticleInput[]
    createMany?: UserReadingRecordCreateManyArticleInputEnvelope
    connect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
  }

  export type UserReadingRecordUpdateManyWithoutArticleNestedInput = {
    create?: XOR<UserReadingRecordCreateWithoutArticleInput, UserReadingRecordUncheckedCreateWithoutArticleInput> | UserReadingRecordCreateWithoutArticleInput[] | UserReadingRecordUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: UserReadingRecordCreateOrConnectWithoutArticleInput | UserReadingRecordCreateOrConnectWithoutArticleInput[]
    upsert?: UserReadingRecordUpsertWithWhereUniqueWithoutArticleInput | UserReadingRecordUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: UserReadingRecordCreateManyArticleInputEnvelope
    set?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    disconnect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    delete?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    connect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    update?: UserReadingRecordUpdateWithWhereUniqueWithoutArticleInput | UserReadingRecordUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: UserReadingRecordUpdateManyWithWhereWithoutArticleInput | UserReadingRecordUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: UserReadingRecordScalarWhereInput | UserReadingRecordScalarWhereInput[]
  }

  export type UserReadingRecordUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<UserReadingRecordCreateWithoutArticleInput, UserReadingRecordUncheckedCreateWithoutArticleInput> | UserReadingRecordCreateWithoutArticleInput[] | UserReadingRecordUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: UserReadingRecordCreateOrConnectWithoutArticleInput | UserReadingRecordCreateOrConnectWithoutArticleInput[]
    upsert?: UserReadingRecordUpsertWithWhereUniqueWithoutArticleInput | UserReadingRecordUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: UserReadingRecordCreateManyArticleInputEnvelope
    set?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    disconnect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    delete?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    connect?: UserReadingRecordWhereUniqueInput | UserReadingRecordWhereUniqueInput[]
    update?: UserReadingRecordUpdateWithWhereUniqueWithoutArticleInput | UserReadingRecordUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: UserReadingRecordUpdateManyWithWhereWithoutArticleInput | UserReadingRecordUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: UserReadingRecordScalarWhereInput | UserReadingRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserReadingRecordsInput = {
    create?: XOR<UserCreateWithoutUserReadingRecordsInput, UserUncheckedCreateWithoutUserReadingRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserReadingRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type ReadingArticleCreateNestedOneWithoutUserReadingRecordsInput = {
    create?: XOR<ReadingArticleCreateWithoutUserReadingRecordsInput, ReadingArticleUncheckedCreateWithoutUserReadingRecordsInput>
    connectOrCreate?: ReadingArticleCreateOrConnectWithoutUserReadingRecordsInput
    connect?: ReadingArticleWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutUserReadingRecordsNestedInput = {
    create?: XOR<UserCreateWithoutUserReadingRecordsInput, UserUncheckedCreateWithoutUserReadingRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserReadingRecordsInput
    upsert?: UserUpsertWithoutUserReadingRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserReadingRecordsInput, UserUpdateWithoutUserReadingRecordsInput>, UserUncheckedUpdateWithoutUserReadingRecordsInput>
  }

  export type ReadingArticleUpdateOneRequiredWithoutUserReadingRecordsNestedInput = {
    create?: XOR<ReadingArticleCreateWithoutUserReadingRecordsInput, ReadingArticleUncheckedCreateWithoutUserReadingRecordsInput>
    connectOrCreate?: ReadingArticleCreateOrConnectWithoutUserReadingRecordsInput
    upsert?: ReadingArticleUpsertWithoutUserReadingRecordsInput
    connect?: ReadingArticleWhereUniqueInput
    update?: XOR<XOR<ReadingArticleUpdateToOneWithWhereWithoutUserReadingRecordsInput, ReadingArticleUpdateWithoutUserReadingRecordsInput>, ReadingArticleUncheckedUpdateWithoutUserReadingRecordsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserVocabularyCreateWithoutUserInput = {
    id?: string
    masteryLevel?: number
    reviewCount?: number
    correctCount?: number
    consecutiveCorrect?: number
    nextReviewAt?: Date | string
    lastReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vocabulary: VocabularyCreateNestedOneWithoutUserVocabulariesInput
  }

  export type UserVocabularyUncheckedCreateWithoutUserInput = {
    id?: string
    masteryLevel?: number
    reviewCount?: number
    correctCount?: number
    consecutiveCorrect?: number
    nextReviewAt?: Date | string
    lastReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vocabularyId: string
  }

  export type UserVocabularyCreateOrConnectWithoutUserInput = {
    where: UserVocabularyWhereUniqueInput
    create: XOR<UserVocabularyCreateWithoutUserInput, UserVocabularyUncheckedCreateWithoutUserInput>
  }

  export type UserVocabularyCreateManyUserInputEnvelope = {
    data: UserVocabularyCreateManyUserInput | UserVocabularyCreateManyUserInput[]
  }

  export type LearningSessionCreateWithoutUserInput = {
    id?: string
    sessionType: string
    startTime?: Date | string
    endTime?: Date | string | null
    totalWords?: number
    correctAnswers?: number
    timeSpent?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionRecords?: LearningSessionRecordCreateNestedManyWithoutSessionInput
  }

  export type LearningSessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionType: string
    startTime?: Date | string
    endTime?: Date | string | null
    totalWords?: number
    correctAnswers?: number
    timeSpent?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionRecords?: LearningSessionRecordUncheckedCreateNestedManyWithoutSessionInput
  }

  export type LearningSessionCreateOrConnectWithoutUserInput = {
    where: LearningSessionWhereUniqueInput
    create: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput>
  }

  export type LearningSessionCreateManyUserInputEnvelope = {
    data: LearningSessionCreateManyUserInput | LearningSessionCreateManyUserInput[]
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    achievementType: string
    achievementValue: number
    unlockedAt?: Date | string
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementType: string
    achievementValue: number
    unlockedAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
  }

  export type UserReadingRecordCreateWithoutUserInput = {
    id?: string
    readingTime: number
    comprehension?: number
    wordsLearned?: number
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    article: ReadingArticleCreateNestedOneWithoutUserReadingRecordsInput
  }

  export type UserReadingRecordUncheckedCreateWithoutUserInput = {
    id?: string
    readingTime: number
    comprehension?: number
    wordsLearned?: number
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articleId: string
  }

  export type UserReadingRecordCreateOrConnectWithoutUserInput = {
    where: UserReadingRecordWhereUniqueInput
    create: XOR<UserReadingRecordCreateWithoutUserInput, UserReadingRecordUncheckedCreateWithoutUserInput>
  }

  export type UserReadingRecordCreateManyUserInputEnvelope = {
    data: UserReadingRecordCreateManyUserInput | UserReadingRecordCreateManyUserInput[]
  }

  export type UserVocabularyUpsertWithWhereUniqueWithoutUserInput = {
    where: UserVocabularyWhereUniqueInput
    update: XOR<UserVocabularyUpdateWithoutUserInput, UserVocabularyUncheckedUpdateWithoutUserInput>
    create: XOR<UserVocabularyCreateWithoutUserInput, UserVocabularyUncheckedCreateWithoutUserInput>
  }

  export type UserVocabularyUpdateWithWhereUniqueWithoutUserInput = {
    where: UserVocabularyWhereUniqueInput
    data: XOR<UserVocabularyUpdateWithoutUserInput, UserVocabularyUncheckedUpdateWithoutUserInput>
  }

  export type UserVocabularyUpdateManyWithWhereWithoutUserInput = {
    where: UserVocabularyScalarWhereInput
    data: XOR<UserVocabularyUpdateManyMutationInput, UserVocabularyUncheckedUpdateManyWithoutUserInput>
  }

  export type UserVocabularyScalarWhereInput = {
    AND?: UserVocabularyScalarWhereInput | UserVocabularyScalarWhereInput[]
    OR?: UserVocabularyScalarWhereInput[]
    NOT?: UserVocabularyScalarWhereInput | UserVocabularyScalarWhereInput[]
    id?: StringFilter<"UserVocabulary"> | string
    masteryLevel?: IntFilter<"UserVocabulary"> | number
    reviewCount?: IntFilter<"UserVocabulary"> | number
    correctCount?: IntFilter<"UserVocabulary"> | number
    consecutiveCorrect?: IntFilter<"UserVocabulary"> | number
    nextReviewAt?: DateTimeFilter<"UserVocabulary"> | Date | string
    lastReviewAt?: DateTimeNullableFilter<"UserVocabulary"> | Date | string | null
    createdAt?: DateTimeFilter<"UserVocabulary"> | Date | string
    updatedAt?: DateTimeFilter<"UserVocabulary"> | Date | string
    userId?: StringFilter<"UserVocabulary"> | string
    vocabularyId?: StringFilter<"UserVocabulary"> | string
  }

  export type LearningSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: LearningSessionWhereUniqueInput
    update: XOR<LearningSessionUpdateWithoutUserInput, LearningSessionUncheckedUpdateWithoutUserInput>
    create: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput>
  }

  export type LearningSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: LearningSessionWhereUniqueInput
    data: XOR<LearningSessionUpdateWithoutUserInput, LearningSessionUncheckedUpdateWithoutUserInput>
  }

  export type LearningSessionUpdateManyWithWhereWithoutUserInput = {
    where: LearningSessionScalarWhereInput
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type LearningSessionScalarWhereInput = {
    AND?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
    OR?: LearningSessionScalarWhereInput[]
    NOT?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
    id?: StringFilter<"LearningSession"> | string
    sessionType?: StringFilter<"LearningSession"> | string
    startTime?: DateTimeFilter<"LearningSession"> | Date | string
    endTime?: DateTimeNullableFilter<"LearningSession"> | Date | string | null
    totalWords?: IntFilter<"LearningSession"> | number
    correctAnswers?: IntFilter<"LearningSession"> | number
    timeSpent?: IntFilter<"LearningSession"> | number
    isActive?: BoolFilter<"LearningSession"> | boolean
    createdAt?: DateTimeFilter<"LearningSession"> | Date | string
    updatedAt?: DateTimeFilter<"LearningSession"> | Date | string
    userId?: StringFilter<"LearningSession"> | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    achievementType?: StringFilter<"UserAchievement"> | string
    achievementValue?: IntFilter<"UserAchievement"> | number
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    userId?: StringFilter<"UserAchievement"> | string
  }

  export type UserReadingRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: UserReadingRecordWhereUniqueInput
    update: XOR<UserReadingRecordUpdateWithoutUserInput, UserReadingRecordUncheckedUpdateWithoutUserInput>
    create: XOR<UserReadingRecordCreateWithoutUserInput, UserReadingRecordUncheckedCreateWithoutUserInput>
  }

  export type UserReadingRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: UserReadingRecordWhereUniqueInput
    data: XOR<UserReadingRecordUpdateWithoutUserInput, UserReadingRecordUncheckedUpdateWithoutUserInput>
  }

  export type UserReadingRecordUpdateManyWithWhereWithoutUserInput = {
    where: UserReadingRecordScalarWhereInput
    data: XOR<UserReadingRecordUpdateManyMutationInput, UserReadingRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type UserReadingRecordScalarWhereInput = {
    AND?: UserReadingRecordScalarWhereInput | UserReadingRecordScalarWhereInput[]
    OR?: UserReadingRecordScalarWhereInput[]
    NOT?: UserReadingRecordScalarWhereInput | UserReadingRecordScalarWhereInput[]
    id?: StringFilter<"UserReadingRecord"> | string
    readingTime?: IntFilter<"UserReadingRecord"> | number
    comprehension?: FloatFilter<"UserReadingRecord"> | number
    wordsLearned?: IntFilter<"UserReadingRecord"> | number
    isCompleted?: BoolFilter<"UserReadingRecord"> | boolean
    createdAt?: DateTimeFilter<"UserReadingRecord"> | Date | string
    updatedAt?: DateTimeFilter<"UserReadingRecord"> | Date | string
    userId?: StringFilter<"UserReadingRecord"> | string
    articleId?: StringFilter<"UserReadingRecord"> | string
  }

  export type VocabularyCreateWithoutCategoryInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userVocabularies?: UserVocabularyCreateNestedManyWithoutVocabularyInput
    sessionRecords?: LearningSessionRecordCreateNestedManyWithoutVocabularyInput
  }

  export type VocabularyUncheckedCreateWithoutCategoryInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userVocabularies?: UserVocabularyUncheckedCreateNestedManyWithoutVocabularyInput
    sessionRecords?: LearningSessionRecordUncheckedCreateNestedManyWithoutVocabularyInput
  }

  export type VocabularyCreateOrConnectWithoutCategoryInput = {
    where: VocabularyWhereUniqueInput
    create: XOR<VocabularyCreateWithoutCategoryInput, VocabularyUncheckedCreateWithoutCategoryInput>
  }

  export type VocabularyCreateManyCategoryInputEnvelope = {
    data: VocabularyCreateManyCategoryInput | VocabularyCreateManyCategoryInput[]
  }

  export type VocabularyUpsertWithWhereUniqueWithoutCategoryInput = {
    where: VocabularyWhereUniqueInput
    update: XOR<VocabularyUpdateWithoutCategoryInput, VocabularyUncheckedUpdateWithoutCategoryInput>
    create: XOR<VocabularyCreateWithoutCategoryInput, VocabularyUncheckedCreateWithoutCategoryInput>
  }

  export type VocabularyUpdateWithWhereUniqueWithoutCategoryInput = {
    where: VocabularyWhereUniqueInput
    data: XOR<VocabularyUpdateWithoutCategoryInput, VocabularyUncheckedUpdateWithoutCategoryInput>
  }

  export type VocabularyUpdateManyWithWhereWithoutCategoryInput = {
    where: VocabularyScalarWhereInput
    data: XOR<VocabularyUpdateManyMutationInput, VocabularyUncheckedUpdateManyWithoutCategoryInput>
  }

  export type VocabularyScalarWhereInput = {
    AND?: VocabularyScalarWhereInput | VocabularyScalarWhereInput[]
    OR?: VocabularyScalarWhereInput[]
    NOT?: VocabularyScalarWhereInput | VocabularyScalarWhereInput[]
    id?: StringFilter<"Vocabulary"> | string
    word?: StringFilter<"Vocabulary"> | string
    pronunciation?: StringNullableFilter<"Vocabulary"> | string | null
    definition?: StringFilter<"Vocabulary"> | string
    example?: StringNullableFilter<"Vocabulary"> | string | null
    difficulty?: IntFilter<"Vocabulary"> | number
    frequency?: IntFilter<"Vocabulary"> | number
    isActive?: BoolFilter<"Vocabulary"> | boolean
    createdAt?: DateTimeFilter<"Vocabulary"> | Date | string
    updatedAt?: DateTimeFilter<"Vocabulary"> | Date | string
    categoryId?: StringFilter<"Vocabulary"> | string
  }

  export type VocabularyCategoryCreateWithoutVocabulariesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VocabularyCategoryUncheckedCreateWithoutVocabulariesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VocabularyCategoryCreateOrConnectWithoutVocabulariesInput = {
    where: VocabularyCategoryWhereUniqueInput
    create: XOR<VocabularyCategoryCreateWithoutVocabulariesInput, VocabularyCategoryUncheckedCreateWithoutVocabulariesInput>
  }

  export type UserVocabularyCreateWithoutVocabularyInput = {
    id?: string
    masteryLevel?: number
    reviewCount?: number
    correctCount?: number
    consecutiveCorrect?: number
    nextReviewAt?: Date | string
    lastReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVocabulariesInput
  }

  export type UserVocabularyUncheckedCreateWithoutVocabularyInput = {
    id?: string
    masteryLevel?: number
    reviewCount?: number
    correctCount?: number
    consecutiveCorrect?: number
    nextReviewAt?: Date | string
    lastReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserVocabularyCreateOrConnectWithoutVocabularyInput = {
    where: UserVocabularyWhereUniqueInput
    create: XOR<UserVocabularyCreateWithoutVocabularyInput, UserVocabularyUncheckedCreateWithoutVocabularyInput>
  }

  export type UserVocabularyCreateManyVocabularyInputEnvelope = {
    data: UserVocabularyCreateManyVocabularyInput | UserVocabularyCreateManyVocabularyInput[]
  }

  export type LearningSessionRecordCreateWithoutVocabularyInput = {
    id?: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt?: Date | string
    session: LearningSessionCreateNestedOneWithoutSessionRecordsInput
  }

  export type LearningSessionRecordUncheckedCreateWithoutVocabularyInput = {
    id?: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt?: Date | string
    sessionId: string
  }

  export type LearningSessionRecordCreateOrConnectWithoutVocabularyInput = {
    where: LearningSessionRecordWhereUniqueInput
    create: XOR<LearningSessionRecordCreateWithoutVocabularyInput, LearningSessionRecordUncheckedCreateWithoutVocabularyInput>
  }

  export type LearningSessionRecordCreateManyVocabularyInputEnvelope = {
    data: LearningSessionRecordCreateManyVocabularyInput | LearningSessionRecordCreateManyVocabularyInput[]
  }

  export type VocabularyCategoryUpsertWithoutVocabulariesInput = {
    update: XOR<VocabularyCategoryUpdateWithoutVocabulariesInput, VocabularyCategoryUncheckedUpdateWithoutVocabulariesInput>
    create: XOR<VocabularyCategoryCreateWithoutVocabulariesInput, VocabularyCategoryUncheckedCreateWithoutVocabulariesInput>
    where?: VocabularyCategoryWhereInput
  }

  export type VocabularyCategoryUpdateToOneWithWhereWithoutVocabulariesInput = {
    where?: VocabularyCategoryWhereInput
    data: XOR<VocabularyCategoryUpdateWithoutVocabulariesInput, VocabularyCategoryUncheckedUpdateWithoutVocabulariesInput>
  }

  export type VocabularyCategoryUpdateWithoutVocabulariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VocabularyCategoryUncheckedUpdateWithoutVocabulariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVocabularyUpsertWithWhereUniqueWithoutVocabularyInput = {
    where: UserVocabularyWhereUniqueInput
    update: XOR<UserVocabularyUpdateWithoutVocabularyInput, UserVocabularyUncheckedUpdateWithoutVocabularyInput>
    create: XOR<UserVocabularyCreateWithoutVocabularyInput, UserVocabularyUncheckedCreateWithoutVocabularyInput>
  }

  export type UserVocabularyUpdateWithWhereUniqueWithoutVocabularyInput = {
    where: UserVocabularyWhereUniqueInput
    data: XOR<UserVocabularyUpdateWithoutVocabularyInput, UserVocabularyUncheckedUpdateWithoutVocabularyInput>
  }

  export type UserVocabularyUpdateManyWithWhereWithoutVocabularyInput = {
    where: UserVocabularyScalarWhereInput
    data: XOR<UserVocabularyUpdateManyMutationInput, UserVocabularyUncheckedUpdateManyWithoutVocabularyInput>
  }

  export type LearningSessionRecordUpsertWithWhereUniqueWithoutVocabularyInput = {
    where: LearningSessionRecordWhereUniqueInput
    update: XOR<LearningSessionRecordUpdateWithoutVocabularyInput, LearningSessionRecordUncheckedUpdateWithoutVocabularyInput>
    create: XOR<LearningSessionRecordCreateWithoutVocabularyInput, LearningSessionRecordUncheckedCreateWithoutVocabularyInput>
  }

  export type LearningSessionRecordUpdateWithWhereUniqueWithoutVocabularyInput = {
    where: LearningSessionRecordWhereUniqueInput
    data: XOR<LearningSessionRecordUpdateWithoutVocabularyInput, LearningSessionRecordUncheckedUpdateWithoutVocabularyInput>
  }

  export type LearningSessionRecordUpdateManyWithWhereWithoutVocabularyInput = {
    where: LearningSessionRecordScalarWhereInput
    data: XOR<LearningSessionRecordUpdateManyMutationInput, LearningSessionRecordUncheckedUpdateManyWithoutVocabularyInput>
  }

  export type LearningSessionRecordScalarWhereInput = {
    AND?: LearningSessionRecordScalarWhereInput | LearningSessionRecordScalarWhereInput[]
    OR?: LearningSessionRecordScalarWhereInput[]
    NOT?: LearningSessionRecordScalarWhereInput | LearningSessionRecordScalarWhereInput[]
    id?: StringFilter<"LearningSessionRecord"> | string
    isCorrect?: BoolFilter<"LearningSessionRecord"> | boolean
    responseTime?: IntFilter<"LearningSessionRecord"> | number
    difficulty?: IntFilter<"LearningSessionRecord"> | number
    createdAt?: DateTimeFilter<"LearningSessionRecord"> | Date | string
    sessionId?: StringFilter<"LearningSessionRecord"> | string
    vocabularyId?: StringFilter<"LearningSessionRecord"> | string
  }

  export type UserCreateWithoutVocabulariesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userReadingRecords?: UserReadingRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVocabulariesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userReadingRecords?: UserReadingRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVocabulariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVocabulariesInput, UserUncheckedCreateWithoutVocabulariesInput>
  }

  export type VocabularyCreateWithoutUserVocabulariesInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: VocabularyCategoryCreateNestedOneWithoutVocabulariesInput
    sessionRecords?: LearningSessionRecordCreateNestedManyWithoutVocabularyInput
  }

  export type VocabularyUncheckedCreateWithoutUserVocabulariesInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
    sessionRecords?: LearningSessionRecordUncheckedCreateNestedManyWithoutVocabularyInput
  }

  export type VocabularyCreateOrConnectWithoutUserVocabulariesInput = {
    where: VocabularyWhereUniqueInput
    create: XOR<VocabularyCreateWithoutUserVocabulariesInput, VocabularyUncheckedCreateWithoutUserVocabulariesInput>
  }

  export type UserUpsertWithoutVocabulariesInput = {
    update: XOR<UserUpdateWithoutVocabulariesInput, UserUncheckedUpdateWithoutVocabulariesInput>
    create: XOR<UserCreateWithoutVocabulariesInput, UserUncheckedCreateWithoutVocabulariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVocabulariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVocabulariesInput, UserUncheckedUpdateWithoutVocabulariesInput>
  }

  export type UserUpdateWithoutVocabulariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userReadingRecords?: UserReadingRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVocabulariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userReadingRecords?: UserReadingRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VocabularyUpsertWithoutUserVocabulariesInput = {
    update: XOR<VocabularyUpdateWithoutUserVocabulariesInput, VocabularyUncheckedUpdateWithoutUserVocabulariesInput>
    create: XOR<VocabularyCreateWithoutUserVocabulariesInput, VocabularyUncheckedCreateWithoutUserVocabulariesInput>
    where?: VocabularyWhereInput
  }

  export type VocabularyUpdateToOneWithWhereWithoutUserVocabulariesInput = {
    where?: VocabularyWhereInput
    data: XOR<VocabularyUpdateWithoutUserVocabulariesInput, VocabularyUncheckedUpdateWithoutUserVocabulariesInput>
  }

  export type VocabularyUpdateWithoutUserVocabulariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: VocabularyCategoryUpdateOneRequiredWithoutVocabulariesNestedInput
    sessionRecords?: LearningSessionRecordUpdateManyWithoutVocabularyNestedInput
  }

  export type VocabularyUncheckedUpdateWithoutUserVocabulariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    sessionRecords?: LearningSessionRecordUncheckedUpdateManyWithoutVocabularyNestedInput
  }

  export type UserCreateWithoutLearningSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    vocabularies?: UserVocabularyCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userReadingRecords?: UserReadingRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLearningSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    vocabularies?: UserVocabularyUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userReadingRecords?: UserReadingRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLearningSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLearningSessionsInput, UserUncheckedCreateWithoutLearningSessionsInput>
  }

  export type LearningSessionRecordCreateWithoutSessionInput = {
    id?: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt?: Date | string
    vocabulary: VocabularyCreateNestedOneWithoutSessionRecordsInput
  }

  export type LearningSessionRecordUncheckedCreateWithoutSessionInput = {
    id?: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt?: Date | string
    vocabularyId: string
  }

  export type LearningSessionRecordCreateOrConnectWithoutSessionInput = {
    where: LearningSessionRecordWhereUniqueInput
    create: XOR<LearningSessionRecordCreateWithoutSessionInput, LearningSessionRecordUncheckedCreateWithoutSessionInput>
  }

  export type LearningSessionRecordCreateManySessionInputEnvelope = {
    data: LearningSessionRecordCreateManySessionInput | LearningSessionRecordCreateManySessionInput[]
  }

  export type UserUpsertWithoutLearningSessionsInput = {
    update: XOR<UserUpdateWithoutLearningSessionsInput, UserUncheckedUpdateWithoutLearningSessionsInput>
    create: XOR<UserCreateWithoutLearningSessionsInput, UserUncheckedCreateWithoutLearningSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLearningSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLearningSessionsInput, UserUncheckedUpdateWithoutLearningSessionsInput>
  }

  export type UserUpdateWithoutLearningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    vocabularies?: UserVocabularyUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userReadingRecords?: UserReadingRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLearningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    vocabularies?: UserVocabularyUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userReadingRecords?: UserReadingRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LearningSessionRecordUpsertWithWhereUniqueWithoutSessionInput = {
    where: LearningSessionRecordWhereUniqueInput
    update: XOR<LearningSessionRecordUpdateWithoutSessionInput, LearningSessionRecordUncheckedUpdateWithoutSessionInput>
    create: XOR<LearningSessionRecordCreateWithoutSessionInput, LearningSessionRecordUncheckedCreateWithoutSessionInput>
  }

  export type LearningSessionRecordUpdateWithWhereUniqueWithoutSessionInput = {
    where: LearningSessionRecordWhereUniqueInput
    data: XOR<LearningSessionRecordUpdateWithoutSessionInput, LearningSessionRecordUncheckedUpdateWithoutSessionInput>
  }

  export type LearningSessionRecordUpdateManyWithWhereWithoutSessionInput = {
    where: LearningSessionRecordScalarWhereInput
    data: XOR<LearningSessionRecordUpdateManyMutationInput, LearningSessionRecordUncheckedUpdateManyWithoutSessionInput>
  }

  export type LearningSessionCreateWithoutSessionRecordsInput = {
    id?: string
    sessionType: string
    startTime?: Date | string
    endTime?: Date | string | null
    totalWords?: number
    correctAnswers?: number
    timeSpent?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLearningSessionsInput
  }

  export type LearningSessionUncheckedCreateWithoutSessionRecordsInput = {
    id?: string
    sessionType: string
    startTime?: Date | string
    endTime?: Date | string | null
    totalWords?: number
    correctAnswers?: number
    timeSpent?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type LearningSessionCreateOrConnectWithoutSessionRecordsInput = {
    where: LearningSessionWhereUniqueInput
    create: XOR<LearningSessionCreateWithoutSessionRecordsInput, LearningSessionUncheckedCreateWithoutSessionRecordsInput>
  }

  export type VocabularyCreateWithoutSessionRecordsInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: VocabularyCategoryCreateNestedOneWithoutVocabulariesInput
    userVocabularies?: UserVocabularyCreateNestedManyWithoutVocabularyInput
  }

  export type VocabularyUncheckedCreateWithoutSessionRecordsInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
    userVocabularies?: UserVocabularyUncheckedCreateNestedManyWithoutVocabularyInput
  }

  export type VocabularyCreateOrConnectWithoutSessionRecordsInput = {
    where: VocabularyWhereUniqueInput
    create: XOR<VocabularyCreateWithoutSessionRecordsInput, VocabularyUncheckedCreateWithoutSessionRecordsInput>
  }

  export type LearningSessionUpsertWithoutSessionRecordsInput = {
    update: XOR<LearningSessionUpdateWithoutSessionRecordsInput, LearningSessionUncheckedUpdateWithoutSessionRecordsInput>
    create: XOR<LearningSessionCreateWithoutSessionRecordsInput, LearningSessionUncheckedCreateWithoutSessionRecordsInput>
    where?: LearningSessionWhereInput
  }

  export type LearningSessionUpdateToOneWithWhereWithoutSessionRecordsInput = {
    where?: LearningSessionWhereInput
    data: XOR<LearningSessionUpdateWithoutSessionRecordsInput, LearningSessionUncheckedUpdateWithoutSessionRecordsInput>
  }

  export type LearningSessionUpdateWithoutSessionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalWords?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLearningSessionsNestedInput
  }

  export type LearningSessionUncheckedUpdateWithoutSessionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalWords?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyUpsertWithoutSessionRecordsInput = {
    update: XOR<VocabularyUpdateWithoutSessionRecordsInput, VocabularyUncheckedUpdateWithoutSessionRecordsInput>
    create: XOR<VocabularyCreateWithoutSessionRecordsInput, VocabularyUncheckedCreateWithoutSessionRecordsInput>
    where?: VocabularyWhereInput
  }

  export type VocabularyUpdateToOneWithWhereWithoutSessionRecordsInput = {
    where?: VocabularyWhereInput
    data: XOR<VocabularyUpdateWithoutSessionRecordsInput, VocabularyUncheckedUpdateWithoutSessionRecordsInput>
  }

  export type VocabularyUpdateWithoutSessionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: VocabularyCategoryUpdateOneRequiredWithoutVocabulariesNestedInput
    userVocabularies?: UserVocabularyUpdateManyWithoutVocabularyNestedInput
  }

  export type VocabularyUncheckedUpdateWithoutSessionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    userVocabularies?: UserVocabularyUncheckedUpdateManyWithoutVocabularyNestedInput
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    vocabularies?: UserVocabularyCreateNestedManyWithoutUserInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
    userReadingRecords?: UserReadingRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    vocabularies?: UserVocabularyUncheckedCreateNestedManyWithoutUserInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    userReadingRecords?: UserReadingRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    vocabularies?: UserVocabularyUpdateManyWithoutUserNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
    userReadingRecords?: UserReadingRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    vocabularies?: UserVocabularyUncheckedUpdateManyWithoutUserNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    userReadingRecords?: UserReadingRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserReadingRecordCreateWithoutArticleInput = {
    id?: string
    readingTime: number
    comprehension?: number
    wordsLearned?: number
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserReadingRecordsInput
  }

  export type UserReadingRecordUncheckedCreateWithoutArticleInput = {
    id?: string
    readingTime: number
    comprehension?: number
    wordsLearned?: number
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserReadingRecordCreateOrConnectWithoutArticleInput = {
    where: UserReadingRecordWhereUniqueInput
    create: XOR<UserReadingRecordCreateWithoutArticleInput, UserReadingRecordUncheckedCreateWithoutArticleInput>
  }

  export type UserReadingRecordCreateManyArticleInputEnvelope = {
    data: UserReadingRecordCreateManyArticleInput | UserReadingRecordCreateManyArticleInput[]
  }

  export type UserReadingRecordUpsertWithWhereUniqueWithoutArticleInput = {
    where: UserReadingRecordWhereUniqueInput
    update: XOR<UserReadingRecordUpdateWithoutArticleInput, UserReadingRecordUncheckedUpdateWithoutArticleInput>
    create: XOR<UserReadingRecordCreateWithoutArticleInput, UserReadingRecordUncheckedCreateWithoutArticleInput>
  }

  export type UserReadingRecordUpdateWithWhereUniqueWithoutArticleInput = {
    where: UserReadingRecordWhereUniqueInput
    data: XOR<UserReadingRecordUpdateWithoutArticleInput, UserReadingRecordUncheckedUpdateWithoutArticleInput>
  }

  export type UserReadingRecordUpdateManyWithWhereWithoutArticleInput = {
    where: UserReadingRecordScalarWhereInput
    data: XOR<UserReadingRecordUpdateManyMutationInput, UserReadingRecordUncheckedUpdateManyWithoutArticleInput>
  }

  export type UserCreateWithoutUserReadingRecordsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    vocabularies?: UserVocabularyCreateNestedManyWithoutUserInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserReadingRecordsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    preferences?: string
    vocabularies?: UserVocabularyUncheckedCreateNestedManyWithoutUserInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserReadingRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserReadingRecordsInput, UserUncheckedCreateWithoutUserReadingRecordsInput>
  }

  export type ReadingArticleCreateWithoutUserReadingRecordsInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    difficulty?: number
    wordCount?: number
    readingTime?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReadingArticleUncheckedCreateWithoutUserReadingRecordsInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    difficulty?: number
    wordCount?: number
    readingTime?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReadingArticleCreateOrConnectWithoutUserReadingRecordsInput = {
    where: ReadingArticleWhereUniqueInput
    create: XOR<ReadingArticleCreateWithoutUserReadingRecordsInput, ReadingArticleUncheckedCreateWithoutUserReadingRecordsInput>
  }

  export type UserUpsertWithoutUserReadingRecordsInput = {
    update: XOR<UserUpdateWithoutUserReadingRecordsInput, UserUncheckedUpdateWithoutUserReadingRecordsInput>
    create: XOR<UserCreateWithoutUserReadingRecordsInput, UserUncheckedCreateWithoutUserReadingRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserReadingRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserReadingRecordsInput, UserUncheckedUpdateWithoutUserReadingRecordsInput>
  }

  export type UserUpdateWithoutUserReadingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    vocabularies?: UserVocabularyUpdateManyWithoutUserNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserReadingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: StringFieldUpdateOperationsInput | string
    vocabularies?: UserVocabularyUncheckedUpdateManyWithoutUserNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReadingArticleUpsertWithoutUserReadingRecordsInput = {
    update: XOR<ReadingArticleUpdateWithoutUserReadingRecordsInput, ReadingArticleUncheckedUpdateWithoutUserReadingRecordsInput>
    create: XOR<ReadingArticleCreateWithoutUserReadingRecordsInput, ReadingArticleUncheckedCreateWithoutUserReadingRecordsInput>
    where?: ReadingArticleWhereInput
  }

  export type ReadingArticleUpdateToOneWithWhereWithoutUserReadingRecordsInput = {
    where?: ReadingArticleWhereInput
    data: XOR<ReadingArticleUpdateWithoutUserReadingRecordsInput, ReadingArticleUncheckedUpdateWithoutUserReadingRecordsInput>
  }

  export type ReadingArticleUpdateWithoutUserReadingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    readingTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingArticleUncheckedUpdateWithoutUserReadingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    readingTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVocabularyCreateManyUserInput = {
    id?: string
    masteryLevel?: number
    reviewCount?: number
    correctCount?: number
    consecutiveCorrect?: number
    nextReviewAt?: Date | string
    lastReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vocabularyId: string
  }

  export type LearningSessionCreateManyUserInput = {
    id?: string
    sessionType: string
    startTime?: Date | string
    endTime?: Date | string | null
    totalWords?: number
    correctAnswers?: number
    timeSpent?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementType: string
    achievementValue: number
    unlockedAt?: Date | string
  }

  export type UserReadingRecordCreateManyUserInput = {
    id?: string
    readingTime: number
    comprehension?: number
    wordsLearned?: number
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articleId: string
  }

  export type UserVocabularyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vocabulary?: VocabularyUpdateOneRequiredWithoutUserVocabulariesNestedInput
  }

  export type UserVocabularyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vocabularyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserVocabularyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vocabularyId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalWords?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionRecords?: LearningSessionRecordUpdateManyWithoutSessionNestedInput
  }

  export type LearningSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalWords?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionRecords?: LearningSessionRecordUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type LearningSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalWords?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementValue?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementValue?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementValue?: IntFieldUpdateOperationsInput | number
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserReadingRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ReadingArticleUpdateOneRequiredWithoutUserReadingRecordsNestedInput
  }

  export type UserReadingRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserReadingRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyCreateManyCategoryInput = {
    id?: string
    word: string
    pronunciation?: string | null
    definition: string
    example?: string | null
    difficulty?: number
    frequency?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VocabularyUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userVocabularies?: UserVocabularyUpdateManyWithoutVocabularyNestedInput
    sessionRecords?: LearningSessionRecordUpdateManyWithoutVocabularyNestedInput
  }

  export type VocabularyUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userVocabularies?: UserVocabularyUncheckedUpdateManyWithoutVocabularyNestedInput
    sessionRecords?: LearningSessionRecordUncheckedUpdateManyWithoutVocabularyNestedInput
  }

  export type VocabularyUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    pronunciation?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVocabularyCreateManyVocabularyInput = {
    id?: string
    masteryLevel?: number
    reviewCount?: number
    correctCount?: number
    consecutiveCorrect?: number
    nextReviewAt?: Date | string
    lastReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type LearningSessionRecordCreateManyVocabularyInput = {
    id?: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt?: Date | string
    sessionId: string
  }

  export type UserVocabularyUpdateWithoutVocabularyInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVocabulariesNestedInput
  }

  export type UserVocabularyUncheckedUpdateWithoutVocabularyInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserVocabularyUncheckedUpdateManyWithoutVocabularyInput = {
    id?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    consecutiveCorrect?: IntFieldUpdateOperationsInput | number
    nextReviewAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningSessionRecordUpdateWithoutVocabularyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: LearningSessionUpdateOneRequiredWithoutSessionRecordsNestedInput
  }

  export type LearningSessionRecordUncheckedUpdateWithoutVocabularyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningSessionRecordUncheckedUpdateManyWithoutVocabularyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningSessionRecordCreateManySessionInput = {
    id?: string
    isCorrect: boolean
    responseTime: number
    difficulty: number
    createdAt?: Date | string
    vocabularyId: string
  }

  export type LearningSessionRecordUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vocabulary?: VocabularyUpdateOneRequiredWithoutSessionRecordsNestedInput
  }

  export type LearningSessionRecordUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vocabularyId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningSessionRecordUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vocabularyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserReadingRecordCreateManyArticleInput = {
    id?: string
    readingTime: number
    comprehension?: number
    wordsLearned?: number
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserReadingRecordUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserReadingRecordsNestedInput
  }

  export type UserReadingRecordUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserReadingRecordUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingTime?: IntFieldUpdateOperationsInput | number
    comprehension?: FloatFieldUpdateOperationsInput | number
    wordsLearned?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VocabularyCategoryCountOutputTypeDefaultArgs instead
     */
    export type VocabularyCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VocabularyCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VocabularyCountOutputTypeDefaultArgs instead
     */
    export type VocabularyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VocabularyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningSessionCountOutputTypeDefaultArgs instead
     */
    export type LearningSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReadingArticleCountOutputTypeDefaultArgs instead
     */
    export type ReadingArticleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReadingArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VocabularyCategoryDefaultArgs instead
     */
    export type VocabularyCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VocabularyCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VocabularyDefaultArgs instead
     */
    export type VocabularyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VocabularyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserVocabularyDefaultArgs instead
     */
    export type UserVocabularyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserVocabularyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningSessionDefaultArgs instead
     */
    export type LearningSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningSessionRecordDefaultArgs instead
     */
    export type LearningSessionRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningSessionRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAchievementDefaultArgs instead
     */
    export type UserAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReadingArticleDefaultArgs instead
     */
    export type ReadingArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReadingArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserReadingRecordDefaultArgs instead
     */
    export type UserReadingRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserReadingRecordDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}